#!/bin/bash

# üöÄ MEGA DEPLOY AUTOM√ÅTICO V3 - Siqueira Campos Im√≥veis
# APAGA TUDO E REFAZ DO ZERO - 100% AUTOM√ÅTICO + LOGS TEMPO REAL
# Desenvolvido por Kryonix - Zero configura√ß√£o manual + Melhorias V3

echo "üöÄ MEGA DEPLOY V3 - INICIANDO..."
echo "üìÖ Data: $(date)"
echo "üîß Configurando para n√£o fechar sozinho..."

# ============= CONFIGURA√á√ïES V3 MELHORADAS =============
# Configura√ß√µes para manter script rodando sem fechar sozinho
set +e  # N√ÉO parar em erros - permitir continuidade
set +u  # N√ÉO parar com vari√°veis n√£o definidas
set -o pipefail  # Manter detec√ß√£o de erros em pipes
IFS=$'\n\t'       # Separador seguro

# Configurar logs em tempo real
LOG_FILE="deploy-$(date +%Y%m%d_%H%M%S).log"

# Fun√ß√£o simplificada para configurar logs
setup_logging() {
    # Backup dos descritores originais
    exec 3>&1 4>&2

    # Configurar log simples
    touch "$LOG_FILE" 2>/dev/null || LOG_FILE="/tmp/deploy-$(date +%s).log"

    echo "üöÄ MEGA DEPLOY V3 iniciado em $(date)" >> "$LOG_FILE"
}

# Configurar output sem buffering
export PYTHONUNBUFFERED=1
export DEBIAN_FRONTEND=noninteractive
stdbuf -oL -eL echo "üöÄ INICIALIZANDO MEGA DEPLOY V3..."

# Configurar logging
setup_logging

# Fun√ß√£o de cleanup melhorada para evitar fechamento abrupto
cleanup() {
    echo ""
    echo "üõë DEPLOY INTERROMPIDO! Executando cleanup..."

    # Parar containers graciosamente
    if command -v docker-compose &> /dev/null; then
        echo "Parando containers..."
        docker-compose down --remove-orphans 2>/dev/null || true
    fi

    # Restaurar descritores de arquivo com seguran√ßa
    exec 1>&3 2>&4 2>/dev/null || true

    echo "üßπ Cleanup conclu√≠do. Pressione ENTER para sair..."
    read -r -t 30 || echo "Timeout - finalizando..."
    exit 1
}

# Configurar traps para diferentes sinais de forma segura
trap cleanup SIGINT SIGTERM 2>/dev/null || true
trap 'echo "Script finalizado normalmente" 2>/dev/null || true' EXIT 2>/dev/null || true

# Sistema avan√ßado de detec√ß√£o e corre√ß√£o autom√°tica de problemas
auto_fix_system() {
    log_info "üîß Iniciando sistema de auto-corre√ß√£o..."

    # 1. Verificar e corrigir espa√ßo em disco
    check_and_fix_disk_space

    # 2. Verificar e corrigir permiss√µes
    check_and_fix_permissions

    # 3. Verificar e corrigir conflitos de porta
    check_and_fix_port_conflicts

    # 4. Verificar e corrigir Docker
    check_and_fix_docker

    # 5. Verificar e corrigir depend√™ncias
    check_and_fix_dependencies

    # 6. Verificar e corrigir firewall
    check_and_fix_firewall

    # 7. Verificar recursos do sistema
    check_system_resources

    # 8. Detectar e corrigir Traefik problem√°tico
    check_and_fix_existing_traefik

    # 9. Detectar e corrigir Portainer existente
    check_and_fix_existing_portainer

    # 10. Configurar Portainers para m√∫ltiplos dom√≠nios
    setup_multi_domain_portainers

    log_success "‚úÖ Sistema de auto-corre√ß√£o conclu√≠do!"
}

# Detectar e corrigir Portainer existente
check_and_fix_existing_portainer() {
    log_info "üê≥ Detectando Portainer existente..."

    # Detectar containers Portainer
    local existing_portainer=$(docker ps -a --filter "name=portainer" --format "{{.Names}}" 2>/dev/null)

    if [ ! -z "$existing_portainer" ]; then
        log_warning "‚ö†Ô∏è Portainer existente detectado: $existing_portainer"

        # Verificar status
        local portainer_status=$(docker ps --filter "name=portainer" --format "{{.Status}}" 2>/dev/null)

        if [ -z "$portainer_status" ]; then
            log_fix "üîß Portainer parado. Removendo container problem√°tico..."
            docker stop $existing_portainer 2>/dev/null || true
            docker rm $existing_portainer 2>/dev/null || true
        else
            log_info "Portainer rodando: $portainer_status"

            # Verificar se tem erro de SSL
            if ! timeout 10 curl -k https://localhost:9443 > /dev/null 2>&1; then
                log_warning "‚ùå Portainer com erro de SSL detectado"

                # Verificar stacks problem√°ticas
                check_portainer_stacks $existing_portainer

                # Backup do Portainer antes de corrigir
                backup_portainer_data $existing_portainer

                # Corrigir SSL do Portainer
                fix_portainer_ssl $existing_portainer
            else
                log_success "‚úÖ Portainer SSL funcionando"
            fi
        fi

        # Remover volumes √≥rf√£os do Portainer
        log_info "üßπ Limpando volumes √≥rf√£os do Portainer..."
        docker volume ls | grep portainer | awk '{print $2}' | while read volume; do
            if ! docker ps -a --filter "volume=$volume" --format "{{.Names}}" | grep -q .; then
                log_fix "Removendo volume √≥rf√£o: $volume"
                docker volume rm $volume 2>/dev/null || true
            fi
        done
    else
        log_info "‚ÑπÔ∏è Nenhum Portainer existente detectado"
    fi
}

# Verificar e corrigir stacks problem√°ticas do Portainer
check_portainer_stacks() {
    local portainer_name="$1"

    log_info "üìã Analisando stacks do Portainer existente..."

    # Detectar todas as stacks (funcionando e quebradas)
    local all_stacks=$(docker ps -a --filter "label=com.docker.compose.project" --format "{{.Label \"com.docker.compose.project\"}}" | sort | uniq)
    local failed_stacks=$(docker ps -a --filter "label=com.docker.compose.project" --filter "status=exited" --format "{{.Label \"com.docker.compose.project\"}}" | sort | uniq)
    local running_stacks=$(docker ps --filter "label=com.docker.compose.project" --format "{{.Label \"com.docker.compose.project\"}}" | sort | uniq)

    local total_stacks=$(echo "$all_stacks" | grep -v '^$' | wc -l)
    local failed_count=$(echo "$failed_stacks" | grep -v '^$' | wc -l)
    local running_count=$(echo "$running_stacks" | grep -v '^$' | wc -l)

    realtime_echo "${CYAN}üìä An√°lise das Stacks:${NC}"
    realtime_echo "   ‚Ä¢ Total de stacks: $total_stacks"
    realtime_echo "   ‚Ä¢ Stacks funcionando: $running_count"
    realtime_echo "   ‚Ä¢ Stacks com problemas: $failed_count"

    if [ $failed_count -gt 0 ]; then
        log_warning "‚ö†Ô∏è Iniciando corre√ß√£o autom√°tica das $failed_count stacks problem√°ticas..."

        echo "$failed_stacks" | while read stack; do
            if [ ! -z "$stack" ]; then
                log_fix "üîß Corrigindo stack: $stack"
                fix_failed_stack "$stack"
            fi
        done

        # Verifica√ß√£o p√≥s-corre√ß√£o
        log_info "üîç Verificando resultados da corre√ß√£o..."
        sleep 15

        local new_running_count=$(docker ps --filter "label=com.docker.compose.project" --format "{{.Label \"com.docker.compose.project\"}}" | sort | uniq | grep -v '^$' | wc -l)
        local fixed_stacks=$((new_running_count - running_count))

        if [ $fixed_stacks -gt 0 ]; then
            log_success "‚úÖ $fixed_stacks stacks foram corrigidas!"
        fi

        realtime_echo "${GREEN}üìà Resultado final:${NC}"
        realtime_echo "   ‚Ä¢ Stacks funcionando agora: $new_running_count/$total_stacks"

    # Se ainda h√° stacks problem√°ticas, aplicar corre√ß√£o avan√ßada
    if [ $new_running_count -lt $total_stacks ]; then
        log_warning "‚ö†Ô∏è Ainda h√° stacks problem√°ticas. Aplicando corre√ß√£o avan√ßada..."
        apply_advanced_stack_fixes
    fi

    # Verificar conflitos entre Traefiks antigo e novo
    check_traefik_conflicts_final
    else
        log_success "‚úÖ Todas as stacks est√£o funcionando corretamente!"
    fi

    # Tentar acessar API do Portainer
    check_portainer_api_access
}

# Aplicar corre√ß√µes avan√ßadas para stacks persistentemente problem√°ticas
apply_advanced_stack_fixes() {
    log_info "üöÄ Aplicando corre√ß√µes avan√ßadas para stacks problem√°ticas..."

    # Estrat√©gia 1: Recrear redes Docker
    log_fix "üåê Recriando redes Docker..."
    docker network prune -f 2>/dev/null || true

    # Estrat√©gia 2: Limpar volumes √≥rf√£os
    log_fix "üíæ Limpando volumes √≥rf√£os..."
    docker volume prune -f 2>/dev/null || true

    # Estrat√©gia 3: Resolver conflitos de porta globalmente
    log_fix "üîå Resolvendo conflitos de porta..."

    # Parar servi√ßos do sistema que podem conflitar
    local system_services=(apache2 nginx mysql postgresql redis-server)
    for service in "${system_services[@]}"; do
        if systemctl is-active --quiet $service 2>/dev/null; then
            log_fix "Parando $service (conflito potencial)..."
            sudo systemctl stop $service 2>/dev/null || true
            sudo systemctl disable $service 2>/dev/null || true
        fi
    done

    # Estrat√©gia 4: Reiniciar Docker daemon
    log_fix "üê≥ Reiniciando Docker daemon..."
    sudo systemctl restart docker 2>/dev/null || true
    sleep 15

    # Estrat√©gia 5: Tentar iniciar stacks uma por uma
    log_fix "üîÑ Reiniciando stacks individualmente..."
    local all_stacks=$(docker ps -a --filter "label=com.docker.compose.project" --format "{{.Label \"com.docker.compose.project\"}}" | sort | uniq)

    echo "$all_stacks" | while read stack; do
        if [ ! -z "$stack" ]; then
            log_info "Reiniciando stack: $stack"

            # Parar todos os containers da stack
            docker ps -a --filter "label=com.docker.compose.project=$stack" --format "{{.Names}}" | while read container; do
                if [ ! -z "$container" ]; then
                    docker stop "$container" 2>/dev/null || true
                    docker rm "$container" 2>/dev/null || true
                fi
            done

            sleep 5

            # Tentar recriar a stack (se poss√≠vel encontrar o compose)
            recreate_stack_if_possible "$stack"
        fi
    done

    log_success "‚úÖ Corre√ß√µes avan√ßadas aplicadas!"
}

# Tentar recriar stack se poss√≠vel
recreate_stack_if_possible() {
    local stack_name="$1"

    # Procurar por docker-compose.yml em locais comuns
    local common_paths=(
        "/opt/$stack_name"
        "/var/lib/docker/volumes/portainer_data/_data/compose/$stack_name"
        "/home/$USER/$stack_name"
        "/root/$stack_name"
        "/opt/stacks/$stack_name"
    )

    for path in "${common_paths[@]}"; do
        if [ -f "$path/docker-compose.yml" ] || [ -f "$path/docker-compose.yaml" ]; then
            log_fix "üìÅ Encontrado compose para $stack_name em $path"

            cd "$path" 2>/dev/null || continue

            # Tentar recriar a stack
            if command -v docker-compose &> /dev/null; then
                docker-compose down 2>/dev/null || true
                sleep 5
                docker-compose up -d 2>/dev/null || true
            fi

            return 0
        fi
    done

    log_warning "‚ö†Ô∏è N√£o foi poss√≠vel encontrar compose para $stack_name"
}

# Verificar acesso √† API do Portainer
check_portainer_api_access() {
    log_info "üîå Verificando acesso √† API do Portainer..."

    local portainer_ports=(9000 9001 9002 9443 9444 9445)
    local accessible_apis=0

    for port in "${portainer_ports[@]}"; do
        if timeout 5 curl -s "http://localhost:$port/api/status" > /dev/null 2>&1; then
            log_success "‚úÖ API Portainer acess√≠vel na porta $port"
            accessible_apis=$((accessible_apis + 1))
        fi
    done

    if [ $accessible_apis -eq 0 ]; then
        log_warning "‚ùå Nenhuma API do Portainer acess√≠vel"

        # Tentar criar um Portainer tempor√°rio para gerenciar stacks
        create_temporary_portainer
    else
        log_success "‚úÖ $accessible_apis APIs do Portainer acess√≠veis"
    fi
}

# Criar Portainer tempor√°rio para gerenciar stacks
create_temporary_portainer() {
    log_fix "üõ†Ô∏è Criando Portainer tempor√°rio para gerenciar stacks..."

    # Remover qualquer Portainer tempor√°rio anterior
    docker stop portainer-temp 2>/dev/null || true
    docker rm portainer-temp 2>/dev/null || true

    # Criar Portainer tempor√°rio
    docker run -d \
        --name portainer-temp \
        -p 9999:9000 \
        -v /var/run/docker.sock:/var/run/docker.sock \
        portainer/portainer-ce:latest \
        2>/dev/null || true

    sleep 10

    if timeout 10 curl -s http://localhost:9999 > /dev/null 2>&1; then
        log_success "‚úÖ Portainer tempor√°rio criado (porta 9999)"
        log_info "Use http://localhost:9999 para gerenciar stacks manualmente se necess√°rio"
    else
        log_warning "‚ùå Falha ao criar Portainer tempor√°rio"
    fi
}

# Corrigir stack que falhou
fix_failed_stack() {
    local stack_name="$1"

    log_fix "üîß Tentando corrigir stack: $stack_name"

    # Obter containers da stack
    local stack_containers=$(docker ps -a --filter "label=com.docker.compose.project=$stack_name" --format "{{.Names}}" 2>/dev/null)

    if [ ! -z "$stack_containers" ]; then
        echo "$stack_containers" | while read container; do
            if [ ! -z "$container" ]; then
                # Verificar logs do container
                local error_logs=$(docker logs --tail=20 "$container" 2>&1)

                # Auto-diagn√≥stico baseado nos logs
                case "$error_logs" in
                    *"port already in use"*|*"address already in use"*)
                        log_fix "Porta ocupada na stack $stack_name. Corrigindo..."
                        # Tentar reiniciar ap√≥s liberar portas
                        docker stop "$container" 2>/dev/null || true
                        sleep 5
                        docker start "$container" 2>/dev/null || true
                        ;;
                    *"no space left"*|*"disk full"*)
                        log_fix "Espa√ßo insuficiente para stack $stack_name. Limpando..."
                        check_and_fix_disk_space
                        docker start "$container" 2>/dev/null || true
                        ;;
                    *"network"*|*"dns"*)
                        log_fix "Problema de rede na stack $stack_name. Recriando rede..."
                        local network=$(docker inspect "$container" --format '{{range .NetworkSettings.Networks}}{{.NetworkID}}{{end}}' 2>/dev/null)
                        if [ ! -z "$network" ]; then
                            docker network disconnect "$network" "$container" 2>/dev/null || true
                            docker network connect "$network" "$container" 2>/dev/null || true
                        fi
                        docker restart "$container" 2>/dev/null || true
                        ;;
                    *)
                        log_fix "Erro gen√©rico na stack $stack_name. Reiniciando..."
                        docker restart "$container" 2>/dev/null || true
                        ;;
                esac
            fi
        done

        # Aguardar containers reiniciarem
        sleep 10

        # Verificar se stack est√° funcionando agora
        local running_containers=$(docker ps --filter "label=com.docker.compose.project=$stack_name" --format "{{.Names}}" | wc -l)
        local total_containers=$(docker ps -a --filter "label=com.docker.compose.project=$stack_name" --format "{{.Names}}" | wc -l)

        if [ $running_containers -eq $total_containers ] && [ $running_containers -gt 0 ]; then
            log_success "‚úÖ Stack $stack_name corrigida!"
        else
            log_warning "‚ö†Ô∏è Stack $stack_name ainda com problemas ($running_containers/$total_containers rodando)"
        fi
    fi
}

# Backup dos dados do Portainer
backup_portainer_data() {
    local portainer_name="$1"

    log_info "üíæ Fazendo backup dos dados do Portainer..."

    local backup_dir="/tmp/portainer-backup-$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"

    # Backup do volume de dados
    if docker volume ls | grep -q portainer_data; then
        log_info "Copiando dados do Portainer..."
        docker run --rm -v portainer_data:/source -v "$backup_dir":/backup alpine cp -r /source/. /backup/ 2>/dev/null || true
    fi

    # Backup de configura√ß√µes do container
    docker inspect "$portainer_name" > "$backup_dir/container_config.json" 2>/dev/null || true

    echo "$backup_dir" > /tmp/portainer_backup_path
    log_success "‚úÖ Backup do Portainer salvo em: $backup_dir"
}

# Corrigir SSL do Portainer existente
fix_portainer_ssl() {
    local portainer_name="$1"

    log_fix "üîí Corrigindo SSL do Portainer..."

    # Parar Portainer atual
    docker stop "$portainer_name" 2>/dev/null || true
    docker rm "$portainer_name" 2>/dev/null || true

    # Recriar Portainer com SSL corrigido
    log_info "Recriando Portainer com configura√ß√£o SSL correta..."
    docker run -d \
        --name portainer-fixed \
        --restart=always \
        -p 8000:8000 \
        -p 9000:9000 \
        -p 9443:9443 \
        -v /var/run/docker.sock:/var/run/docker.sock \
        -v portainer_data:/data \
        --label "traefik.enable=true" \
        --label "traefik.http.routers.portainer.rule=Host(\`portainer.${DOMAIN}\`)" \
        --label "traefik.http.routers.portainer.entrypoints=websecure" \
        --label "traefik.http.routers.portainer.tls.certresolver=letsencrypt" \
        --label "traefik.http.services.portainer.loadbalancer.server.port=9000" \
        portainer/portainer-ce:latest \
        --sslcert /data/portainer.crt \
        --sslkey /data/portainer.key \
        2>/dev/null || true

    # Aguardar Portainer iniciar
    sleep 15

    # Verificar se funcionou
    if timeout 10 curl -s http://localhost:9000 > /dev/null 2>&1; then
        log_success "‚úÖ Portainer SSL corrigido!"
    else
        log_warning "‚ö†Ô∏è Ainda h√° problemas com o Portainer"
    fi
}

# Configurar m√∫ltiplos Portainers para diferentes dom√≠nios
setup_multi_domain_portainers() {
    log_info "üåê Configurando Portainers para m√∫ltiplos dom√≠nios..."

    # Solicitar dom√≠nios se n√£o definidos
    if [ -z "${DOMAIN2:-}" ]; then
        log_info "üìù Configure os dom√≠nios para os Portainers:"
        realtime_echo "${YELLOW}Dom√≠nio 1 (atual): $DOMAIN${NC}"
        realtime_echo "${CYAN}Digite o segundo dom√≠nio (ex: example2.com):${NC}"

        # Aguardar input com timeout
        read -t 30 -r DOMAIN2 || DOMAIN2="portainer2.local"

        if [ -z "$DOMAIN2" ]; then
            DOMAIN2="portainer2.local"
            log_warning "Usando dom√≠nio padr√£o: $DOMAIN2"
        fi
    fi

    log_info "üèóÔ∏è Configurando Portainer 1 para: $DOMAIN"
    log_info "üèóÔ∏è Configurando Portainer 2 para: $DOMAIN2"

    # Parar qualquer Portainer existente conflitante
    docker stop portainer portainer-fixed 2>/dev/null || true
    docker rm portainer portainer-fixed 2>/dev/null || true

    # Criar Portainer 1 (dom√≠nio principal)
    create_portainer_instance "portainer1" "$DOMAIN" "9001" "9444"

    # Criar Portainer 2 (segundo dom√≠nio)
    create_portainer_instance "portainer2" "$DOMAIN2" "9002" "9445"

    # Aguardar ambos iniciarem
    log_info "‚è≥ Aguardando Portainers iniciarem..."
    sleep 30

    # Verificar se ambos est√£o funcionando
    verify_portainer_instances
}

# Criar inst√¢ncia do Portainer
create_portainer_instance() {
    local instance_name="$1"
    local domain="$2"
    local http_port="$3"
    local https_port="$4"

    log_info "üê≥ Criando $instance_name para $domain..."

    # Criar volume espec√≠fico para esta inst√¢ncia
    docker volume create "${instance_name}_data" 2>/dev/null || true

    # Criar container Portainer
    docker run -d \
        --name "$instance_name" \
        --restart=always \
        -p "$http_port:9000" \
        -p "$https_port:9443" \
        -v /var/run/docker.sock:/var/run/docker.sock \
        -v "${instance_name}_data:/data" \
        --network siqueira-network \
        --label "traefik.enable=true" \
        --label "traefik.http.routers.${instance_name}.rule=Host(\`portainer.${domain}\`)" \
        --label "traefik.http.routers.${instance_name}.entrypoints=websecure" \
        --label "traefik.http.routers.${instance_name}.tls.certresolver=letsencrypt" \
        --label "traefik.http.services.${instance_name}.loadbalancer.server.port=9000" \
        --label "traefik.http.middlewares.${instance_name}-redirect.redirectscheme.scheme=https" \
        --label "traefik.http.routers.${instance_name}-redirect.rule=Host(\`portainer.${domain}\`)" \
        --label "traefik.http.routers.${instance_name}-redirect.entrypoints=web" \
        --label "traefik.http.routers.${instance_name}-redirect.middlewares=${instance_name}-redirect" \
        portainer/portainer-ce:latest \
        2>/dev/null || true

    if [ $? -eq 0 ]; then
        log_success "‚úÖ $instance_name criado com sucesso!"
        log_info "   ‚Ä¢ HTTP: http://localhost:$http_port"
        log_info "   ‚Ä¢ HTTPS: https://localhost:$https_port"
        log_info "   ‚Ä¢ Dom√≠nio: https://portainer.$domain"
    else
        log_error "‚ùå Falha ao criar $instance_name"
    fi
}

# Verificar inst√¢ncias do Portainer
verify_portainer_instances() {
    log_info "üîç Verificando inst√¢ncias do Portainer..."

    local portainer1_status="‚ùå"
    local portainer2_status="‚ùå"

    # Verificar Portainer 1
    if timeout 10 curl -s http://localhost:9001 > /dev/null 2>&1; then
        portainer1_status="‚úÖ"
        log_success "‚úÖ Portainer 1 funcionando (porta 9001)"
    else
        log_warning "‚ùå Portainer 1 n√£o responde"

        # Tentar corrigir
        docker restart portainer1 2>/dev/null || true
        sleep 10

        if timeout 10 curl -s http://localhost:9001 > /dev/null 2>&1; then
            portainer1_status="‚úÖ"
            log_success "‚úÖ Portainer 1 corrigido!"
        fi
    fi

    # Verificar Portainer 2
    if timeout 10 curl -s http://localhost:9002 > /dev/null 2>&1; then
        portainer2_status="‚úÖ"
        log_success "‚úÖ Portainer 2 funcionando (porta 9002)"
    else
        log_warning "‚ùå Portainer 2 n√£o responde"

        # Tentar corrigir
        docker restart portainer2 2>/dev/null || true
        sleep 10

        if timeout 10 curl -s http://localhost:9002 > /dev/null 2>&1; then
            portainer2_status="‚úÖ"
            log_success "‚úÖ Portainer 2 corrigido!"
        fi
    fi

    # Relat√≥rio final dos Portainers
    realtime_echo ""
    realtime_echo "${CYAN}üìä Status dos Portainers:${NC}"
    realtime_echo "   $portainer1_status Portainer 1: https://portainer.$DOMAIN"
    realtime_echo "   $portainer2_status Portainer 2: https://portainer.${DOMAIN2:-"domain2.local"}"
    realtime_echo ""
}

# Verificar e corrigir espa√ßo em disco
check_and_fix_disk_space() {
    log_info "üíæ Verificando espa√ßo em disco..."

    local available_space=$(df / | awk 'NR==2 {print $4}')
    local available_gb=$((available_space / 1024 / 1024))

    if [ $available_gb -lt 2 ]; then
        log_warning "‚ö†Ô∏è Pouco espa√ßo em disco (${available_gb}GB). Limpando..."

        # Limpeza autom√°tica
        sudo apt autoremove -y 2>/dev/null || true
        sudo apt autoclean -y 2>/dev/null || true
        sudo journalctl --vacuum-time=7d 2>/dev/null || true
        docker system prune -f 2>/dev/null || true

        # Verificar novamente
        available_space=$(df / | awk 'NR==2 {print $4}')
        available_gb=$((available_space / 1024 / 1024))

        if [ $available_gb -lt 1 ]; then
            log_error "‚ùå Espa√ßo em disco insuficiente (${available_gb}GB). Continuando com risco..."
        else
            log_success "‚úÖ Espa√ßo liberado. Dispon√≠vel: ${available_gb}GB"
        fi
    else
        log_success "‚úÖ Espa√ßo em disco suficiente: ${available_gb}GB"
    fi
}

# Verificar e corrigir permiss√µes
check_and_fix_permissions() {
    log_info "üîê Verificando permiss√µes..."

    # Verificar se usu√°rio est√° no grupo docker
    if ! groups | grep -q docker; then
        log_fix "Adicionando usu√°rio ao grupo docker..."
        sudo usermod -aG docker $USER || true
        log_warning "‚ö†Ô∏è Necess√°rio logout/login para ativar grupo docker"
    fi

    # Corrigir permiss√µes do diret√≥rio atual
    if [ ! -w "." ]; then
        log_fix "Corrigindo permiss√µes do diret√≥rio..."
        sudo chown -R $USER:$USER . 2>/dev/null || true
    fi

    # Verificar permiss√µes do Docker socket
    if [ -S /var/run/docker.sock ] && [ ! -w /var/run/docker.sock ]; then
        log_fix "Corrigindo permiss√µes do Docker socket..."
        sudo chmod 666 /var/run/docker.sock 2>/dev/null || true
    fi

    log_success "‚úÖ Permiss√µes verificadas"
}

# Verificar e corrigir conflitos de porta avan√ßado
check_and_fix_port_conflicts() {
    log_info "üîå Verificando conflitos de porta avan√ßados..."

    local ports_to_check=(80 443 3000 3001 5432 6379 8080)
    local conflicts_found=false

    for port in "${ports_to_check[@]}"; do
        local process=$(sudo netstat -tlnp 2>/dev/null | grep ":$port " | awk '{print $7}' | head -1)

        if [ ! -z "$process" ]; then
            log_warning "‚ö†Ô∏è Porta $port ocupada por: $process"
            conflicts_found=true

            # Auto-resolver conflitos conhecidos
            case $port in
                80|443)
                    # Parar servi√ßos web
                    for service in apache2 nginx lighttpd; do
                        if systemctl is-active --quiet $service 2>/dev/null; then
                            log_fix "Parando $service..."
                            sudo systemctl stop $service 2>/dev/null || true
                            sudo systemctl disable $service 2>/dev/null || true
                        fi
                    done
                    ;;
                3000|3001)
                    # Matar processos Node.js/development servers
                    log_fix "Matando processos na porta $port..."
                    sudo fuser -k $port/tcp 2>/dev/null || true
                    ;;
                5432)
                    # PostgreSQL conflito
                    if systemctl is-active --quiet postgresql 2>/dev/null; then
                        log_fix "Parando PostgreSQL sistema..."
                        sudo systemctl stop postgresql 2>/dev/null || true
                    fi
                    ;;
                6379)
                    # Redis conflito
                    if systemctl is-active --quiet redis-server 2>/dev/null; then
                        log_fix "Parando Redis sistema..."
                        sudo systemctl stop redis-server 2>/dev/null || true
                    fi
                    ;;
            esac
        fi
    done

    if [ "$conflicts_found" = true ]; then
        log_warning "Aguardando 5s para processos terminarem..."
        sleep 5
        USE_ALT_PORTS=true
    else
        log_success "‚úÖ Todas as portas est√£o livres"
        USE_ALT_PORTS=false
    fi
}

# Verificar e corrigir Docker
check_and_fix_docker() {
    log_info "üê≥ Verificando Docker..."

    # Verificar se Docker est√° instalado
    if ! command -v docker &> /dev/null; then
        log_fix "Docker n√£o encontrado. Instalando..."
        curl -fsSL https://get.docker.com -o get-docker.sh
        sudo sh get-docker.sh
        sudo usermod -aG docker $USER
        rm get-docker.sh
    fi

    # Verificar se Docker est√° rodando
    if ! sudo systemctl is-active --quiet docker; then
        log_fix "Docker n√£o est√° rodando. Iniciando..."
        sudo systemctl start docker || true
        sudo systemctl enable docker || true
        sleep 5
    fi

    # Verificar se Docker responde
    if ! docker ps &> /dev/null; then
        log_fix "Docker n√£o responde. Reiniciando servi√ßo..."
        sudo systemctl restart docker || true
        sleep 10

        # Se ainda n√£o funciona, tentar repair
        if ! docker ps &> /dev/null; then
            log_fix "Tentando reparo do Docker..."
            sudo systemctl stop docker || true
            sudo rm -rf /var/lib/docker/network 2>/dev/null || true
            sudo systemctl start docker || true
            sleep 10
        fi
    fi

    # Verificar Docker Compose
    if ! command -v docker-compose &> /dev/null; then
        log_fix "Docker Compose n√£o encontrado. Instalando..."
        sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
        sudo chmod +x /usr/local/bin/docker-compose
    fi

    # Limpeza preventiva do Docker
    log_info "Limpeza preventiva do Docker..."
    docker system prune -f 2>/dev/null || true

    log_success "‚úÖ Docker verificado e corrigido"
}

# Verificar e corrigir depend√™ncias
check_and_fix_dependencies() {
    log_info "üì¶ Verificando depend√™ncias..."

    local required_packages=(curl wget git unzip htop nano ufw net-tools)
    local missing_packages=()

    for package in "${required_packages[@]}"; do
        if ! command -v $package &> /dev/null && ! dpkg -l | grep -q "^ii  $package "; then
            missing_packages+=($package)
        fi
    done

    if [ ${#missing_packages[@]} -gt 0 ]; then
        log_fix "Instalando pacotes em falta: ${missing_packages[*]}"
        sudo apt update 2>/dev/null || true
        sudo apt install -y "${missing_packages[@]}" 2>/dev/null || true
    fi

    # Verificar se sistema est√° atualizado
    local updates=$(apt list --upgradable 2>/dev/null | wc -l)
    if [ $updates -gt 10 ]; then
        log_warning "Sistema com muitas atualiza√ß√µes pendentes ($updates). Atualizando..."
        sudo apt update && sudo apt upgrade -y 2>/dev/null || true
    fi

    log_success "‚úÖ Depend√™ncias verificadas"
}

# Verificar e corrigir firewall
check_and_fix_firewall() {
    log_info "üî• Verificando firewall..."

    # Verificar se UFW est√° instalado
    if ! command -v ufw &> /dev/null; then
        log_fix "UFW n√£o encontrado. Instalando..."
        sudo apt install -y ufw 2>/dev/null || true
    fi

    # Verificar status do firewall
    local ufw_status=$(sudo ufw status 2>/dev/null | head -1)

    if echo "$ufw_status" | grep -q "inactive"; then
        log_fix "Firewall inativo. Configurando..."
        sudo ufw --force reset 2>/dev/null || true
        sudo ufw allow 22/tcp 2>/dev/null || true
        sudo ufw allow 80/tcp 2>/dev/null || true
        sudo ufw allow 443/tcp 2>/dev/null || true
        sudo ufw allow 8000/tcp 2>/dev/null || true
        sudo ufw allow 8080/tcp 2>/dev/null || true
        sudo ufw allow 8443/tcp 2>/dev/null || true
        sudo ufw --force enable 2>/dev/null || true
    fi

    log_success "‚úÖ Firewall configurado"
}

# Sistema completo de detec√ß√£o e corre√ß√£o do Traefik problem√°tico
check_and_fix_existing_traefik() {
    log_info "üîÄ Detectando Traefik existente..."

    # Detectar containers Traefik
    local existing_traefik=$(docker ps -a --filter "name=traefik" --format "{{.Names}}" 2>/dev/null)

    if [ ! -z "$existing_traefik" ]; then
        log_warning "‚ö†Ô∏è Traefik existente detectado: $existing_traefik"

        # Analisar problemas do Traefik
        analyze_traefik_issues "$existing_traefik"

        # Backup do Traefik antes de corrigir
        backup_traefik_data "$existing_traefik"

        # Corrigir problemas espec√≠ficos
        fix_traefik_comprehensive "$existing_traefik"
    else
        # Verificar se h√° Traefik em stacks
        local traefik_in_stacks=$(docker ps -a --filter "label=com.docker.compose.service=traefik" --format "{{.Names}}" 2>/dev/null)

        if [ ! -z "$traefik_in_stacks" ]; then
            log_warning "‚ö†Ô∏è Traefik em stack detectado: $traefik_in_stacks"
            analyze_traefik_issues "$traefik_in_stacks"
            fix_traefik_in_stack "$traefik_in_stacks"
        else
            log_info "‚ÑπÔ∏è Nenhum Traefik problem√°tico detectado"
        fi
    fi
}

# An√°lise completa dos problemas do Traefik
analyze_traefik_issues() {
    local traefik_name="$1"

    log_info "üîç Analisando problemas do Traefik: $traefik_name"

    # Verificar se est√° rodando
    local traefik_status=$(docker ps --filter "name=$traefik_name" --format "{{.Status}}" 2>/dev/null)

    if [ -z "$traefik_status" ]; then
        log_error "‚ùå Traefik n√£o est√° rodando"

        # Verificar logs do container parado
        local error_logs=$(docker logs --tail=20 "$traefik_name" 2>&1)
        log_info "üìã Logs do erro:"
        echo "$error_logs" | head -10

        # Analisar causa da parada
        case "$error_logs" in
            *"port already in use"*|*"bind: address already in use"*)
                log_warning "üîå Problema: Conflito de porta detectado"
                fix_traefik_port_conflict "$traefik_name"
                ;;
            *"certificate"*|*"SSL"*|*"TLS"*)
                log_warning "üîí Problema: Erro de certificado SSL/TLS"
                fix_traefik_ssl_issues "$traefik_name"
                ;;
            *"no such file"*|*"permission denied"*)
                log_warning "üìÅ Problema: Arquivo ou permiss√£o"
                fix_traefik_file_permissions "$traefik_name"
                ;;
            *)
                log_warning "‚ùì Problema gen√©rico detectado"
                ;;
        esac
    else
        log_info "‚úÖ Traefik est√° rodando: $traefik_status"

        # Verificar se dashboard est√° acess√≠vel
        test_traefik_dashboard "$traefik_name"

        # Verificar problemas de proxy reverso
        test_traefik_proxy_reverse "$traefik_name"

        # Verificar certificados SSL
        verify_traefik_ssl_status "$traefik_name"
    fi
}

# Testar dashboard do Traefik
test_traefik_dashboard() {
    local traefik_name="$1"

    log_info "üåê Testando dashboard do Traefik..."

    local dashboard_ports=(8080 8081 9000 9090)
    local dashboard_accessible=false

    for port in "${dashboard_ports[@]}"; do
        if timeout 5 curl -s "http://localhost:$port/api/overview" > /dev/null 2>&1; then
            log_success "‚úÖ Dashboard Traefik acess√≠vel na porta $port"
            dashboard_accessible=true
            break
        fi
    done

    if [ "$dashboard_accessible" = false ]; then
        log_warning "‚ùå Dashboard Traefik n√£o acessÔøΩÔøΩvel"

        # Verificar configura√ß√£o do dashboard
        local traefik_config=$(docker inspect "$traefik_name" --format '{{.Config.Cmd}}' 2>/dev/null)

        if echo "$traefik_config" | grep -q "api.dashboard=true"; then
            log_info "Dashboard habilitado na configura√ß√£o"
        else
            log_warning "Dashboard n√£o habilitado - corrigindo..."
            enable_traefik_dashboard "$traefik_name"
        fi
    fi
}

# Testar proxy reverso do Traefik
test_traefik_proxy_reverse() {
    local traefik_name="$1"

    log_info "üîÑ Testando proxy reverso do Traefik..."

    # Verificar se Traefik est√° fazendo proxy para outros servi√ßos
    local proxy_errors=0

    # Testar portas comuns de proxy
    local proxy_ports=(80 443)

    for port in "${proxy_ports[@]}"; do
        if ! timeout 5 curl -s "http://localhost:$port" > /dev/null 2>&1; then
            log_warning "‚ùå Proxy na porta $port n√£o funcionando"
            proxy_errors=$((proxy_errors + 1))
        else
            # Verificar se est√° retornando erro de Gateway
            local response=$(timeout 5 curl -s -o /dev/null -w "%{http_code}" "http://localhost:$port" 2>/dev/null)

            case "$response" in
                "502"|"503"|"504")
                    log_warning "‚ùå Erro de Gateway ($response) na porta $port"
                    proxy_errors=$((proxy_errors + 1))
                    ;;
                "200"|"301"|"302")
                    log_success "‚úÖ Proxy funcionando na porta $port"
                    ;;
                *)
                    log_info "‚ÑπÔ∏è Resposta $response na porta $port"
                    ;;
            esac
        fi
    done

    if [ $proxy_errors -gt 0 ]; then
        log_warning "‚ö†Ô∏è $proxy_errors problemas de proxy detectados"
        fix_traefik_proxy_issues "$traefik_name"
    else
        log_success "‚úÖ Proxy reverso funcionando"
    fi
}

# Verificar status SSL do Traefik
verify_traefik_ssl_status() {
    local traefik_name="$1"

    log_info "üîí Verificando status SSL do Traefik..."

    # Verificar se h√° certificados
    local cert_volume=$(docker inspect "$traefik_name" --format '{{range .Mounts}}{{if eq .Destination "/acme.json"}}{{.Source}}{{end}}{{end}}' 2>/dev/null)

    if [ ! -z "$cert_volume" ] && [ -f "$cert_volume" ]; then
        local cert_size=$(stat -c%s "$cert_volume" 2>/dev/null || echo "0")

        if [ "$cert_size" -gt 100 ]; then
            log_success "‚úÖ Arquivo de certificados existe ($cert_size bytes)"

            # Verificar se certificados s√£o v√°lidos
            if timeout 5 openssl x509 -in "$cert_volume" -text -noout > /dev/null 2>&1; then
                log_success "‚úÖ Certificados SSL v√°lidos"
            else
                log_warning "‚ùå Certificados SSL corrompidos"
                fix_traefik_ssl_certificates "$traefik_name"
            fi
        else
            log_warning "‚ùå Arquivo de certificados vazio ou corrompido"
            fix_traefik_ssl_certificates "$traefik_name"
        fi
    else
        log_warning "‚ùå Arquivo de certificados n√£o encontrado"
        fix_traefik_ssl_certificates "$traefik_name"
    fi
}

# Corrigir conflitos de porta do Traefik
fix_traefik_port_conflict() {
    local traefik_name="$1"

    log_fix "üîå Corrigindo conflitos de porta do Traefik..."

    # Verificar e parar servi√ßos conflitantes
    local conflicting_ports=(80 443 8080)

    for port in "${conflicting_ports[@]}"; do
        local process=$(sudo netstat -tlnp 2>/dev/null | grep ":$port " | awk '{print $7}' | head -1)

        if [ ! -z "$process" ] && ! echo "$process" | grep -q "docker"; then
            log_fix "Liberando porta $port (processo: $process)"

            # Matar processo espec√≠fico
            local pid=$(echo "$process" | cut -d'/' -f1)
            if [ ! -z "$pid" ] && [ "$pid" != "-" ]; then
                sudo kill -9 "$pid" 2>/dev/null || true
            fi
        fi
    done

    # Parar containers Docker conflitantes
    local conflicting_containers=$(docker ps --filter "publish=80" --filter "publish=443" --format "{{.Names}}" | grep -v "$traefik_name")

    if [ ! -z "$conflicting_containers" ]; then
        echo "$conflicting_containers" | while read container; do
            if [ ! -z "$container" ]; then
                log_fix "Parando container conflitante: $container"
                docker stop "$container" 2>/dev/null || true
            fi
        done
    fi

    # Tentar reiniciar Traefik
    log_info "Reiniciando Traefik ap√≥s liberar portas..."
    docker restart "$traefik_name" 2>/dev/null || true
    sleep 10
}

# Corrigir problemas SSL do Traefik
fix_traefik_ssl_issues() {
    local traefik_name="$1"

    log_fix "üîí Corrigindo problemas SSL do Traefik..."

    # Parar Traefik
    docker stop "$traefik_name" 2>/dev/null || true

    # Localizar e limpar certificados corrompidos
    local cert_paths=(
        "/var/lib/docker/volumes/traefik_acme/_data/acme.json"
        "/var/lib/docker/volumes/*traefik*/_data/acme.json"
        "/opt/traefik/acme.json"
        "/etc/traefik/acme.json"
    )

    for path in "${cert_paths[@]}"; do
        if [ -f "$path" ]; then
            log_fix "Removendo certificados corrompidos: $path"
            sudo rm -f "$path" 2>/dev/null || true
        fi
    done

    # Recriar arquivo acme.json com permiss√µes corretas
    local acme_volume=$(docker volume ls | grep -E "(traefik|acme)" | awk '{print $2}' | head -1)

    if [ ! -z "$acme_volume" ]; then
        log_fix "Recriando acme.json no volume: $acme_volume"
        docker run --rm -v "$acme_volume:/data" alpine sh -c "touch /data/acme.json && chmod 600 /data/acme.json" 2>/dev/null || true
    fi

    # Reiniciar Traefik
    docker start "$traefik_name" 2>/dev/null || true
    sleep 15

    log_success "‚úÖ Problemas SSL corrigidos"
}

# Corrigir permiss√µes de arquivos do Traefik
fix_traefik_file_permissions() {
    local traefik_name="$1"

    log_fix "üìÅ Corrigindo permiss√µes do Traefik..."

    # Corrigir permiss√µes do socket Docker
    sudo chmod 666 /var/run/docker.sock 2>/dev/null || true

    # Corrigir permiss√µes de volumes Traefik
    local traefik_volumes=$(docker inspect "$traefik_name" --format '{{range .Mounts}}{{.Source}} {{end}}' 2>/dev/null)

    if [ ! -z "$traefik_volumes" ]; then
        echo "$traefik_volumes" | while read volume; do
            if [ ! -z "$volume" ] && [ -d "$volume" ]; then
                log_fix "Corrigindo permiss√µes: $volume"
                sudo chown -R root:docker "$volume" 2>/dev/null || true
                sudo chmod -R 755 "$volume" 2>/dev/null || true
            fi
        done
    fi

    # Reiniciar Traefik
    docker restart "$traefik_name" 2>/dev/null || true
    sleep 10
}

# Habilitar dashboard do Traefik
enable_traefik_dashboard() {
    local traefik_name="$1"

    log_fix "üåê Habilitando dashboard do Traefik..."

    # Obter configura√ß√£o atual
    local current_cmd=$(docker inspect "$traefik_name" --format '{{.Config.Cmd}}' 2>/dev/null)

    # Parar container atual
    docker stop "$traefik_name" 2>/dev/null || true
    docker rm "$traefik_name" 2>/dev/null || true

    # Recriar com dashboard habilitado
    log_info "Recriando Traefik com dashboard habilitado..."

    # Tentar encontrar volumes existentes
    local traefik_volumes=$(docker volume ls | grep -E "(traefik|acme)" | awk '{print $2}')
    local volume_args=""

    if [ ! -z "$traefik_volumes" ]; then
        echo "$traefik_volumes" | while read volume; do
            volume_args="$volume_args -v $volume:/data"
        done
    fi

    # Criar novo Traefik com configura√ß√£o correta
    docker run -d \
        --name "${traefik_name}-fixed" \
        --restart=unless-stopped \
        -p 80:80 \
        -p 443:443 \
        -p 8080:8080 \
        -v /var/run/docker.sock:/var/run/docker.sock:ro \
        $volume_args \
        traefik:latest \
        --api.dashboard=true \
        --api.insecure=true \
        --entrypoints.web.address=:80 \
        --entrypoints.websecure.address=:443 \
        --providers.docker=true \
        --providers.docker.exposedbydefault=false \
        --certificatesresolvers.letsencrypt.acme.email="$EMAIL" \
        --certificatesresolvers.letsencrypt.acme.storage=/data/acme.json \
        --certificatesresolvers.letsencrypt.acme.httpchallenge=true \
        --certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web \
        --log.level=INFO \
        2>/dev/null || true

    sleep 15

    # Verificar se funcionou
    if timeout 10 curl -s http://localhost:8080/api/overview > /dev/null 2>&1; then
        log_success "‚úÖ Dashboard Traefik habilitado e funcionando!"
    else
        log_warning "‚ö†Ô∏è Ainda h√° problemas com o dashboard"
    fi
}

# Corrigir problemas de proxy do Traefik
fix_traefik_proxy_issues() {
    local traefik_name="$1"

    log_fix "üîÑ Corrigindo problemas de proxy do Traefik..."

    # Verificar configura√ß√£o de redes
    local traefik_networks=$(docker inspect "$traefik_name" --format '{{range .NetworkSettings.Networks}}{{.NetworkID}} {{end}}' 2>/dev/null)

    # Recriar redes se necess√°rio
    if [ -z "$traefik_networks" ]; then
        log_fix "Reconectando Traefik √†s redes..."

        # Tentar conectar √† rede bridge padr√£o
        docker network connect bridge "$traefik_name" 2>/dev/null || true

        # Tentar conectar a redes de compose
        local compose_networks=$(docker network ls --filter "driver=bridge" --format "{{.Name}}" | grep -v bridge)

        echo "$compose_networks" | while read network; do
            if [ ! -z "$network" ]; then
                docker network connect "$network" "$traefik_name" 2>/dev/null || true
            fi
        done
    fi

    # Verificar se servi√ßos backend est√£o acess√≠veis
    log_info "Verificando conectividade com servi√ßos backend..."

    # Reiniciar Traefik para aplicar mudan√ßas
    docker restart "$traefik_name" 2>/dev/null || true
    sleep 15

    # Testar novamente
    if timeout 5 curl -s http://localhost:80 > /dev/null 2>&1; then
        log_success "‚úÖ Proxy reverso corrigido!"
    else
        log_warning "‚ö†Ô∏è Proxy ainda com problemas - pode precisar reconfigura√ß√£o manual"
    fi
}

# Corrigir certificados SSL
fix_traefik_ssl_certificates() {
    local traefik_name="$1"

    log_fix "üîí Regenerando certificados SSL..."

    # Parar Traefik temporariamente
    docker stop "$traefik_name" 2>/dev/null || true

    # Limpar todos os certificados antigos
    docker run --rm -v traefik_acme:/data alpine sh -c "rm -f /data/acme.json && touch /data/acme.json && chmod 600 /data/acme.json" 2>/dev/null || true

    # Reiniciar Traefik para gerar novos certificados
    docker start "$traefik_name" 2>/dev/null || true

    log_info "‚è≥ Aguardando gera√ß√£o de novos certificados SSL..."
    sleep 30

    # Verificar se certificados foram gerados
    local new_cert_size=$(docker run --rm -v traefik_acme:/data alpine stat -c%s /data/acme.json 2>/dev/null || echo "0")

    if [ "$new_cert_size" -gt 100 ]; then
        log_success "‚úÖ Novos certificados SSL gerados!"
    else
        log_warning "‚ö†Ô∏è Certificados ainda n√£o foram gerados - pode levar alguns minutos"
    fi
}

# Backup dados do Traefik
backup_traefik_data() {
    local traefik_name="$1"

    log_info "üíæ Fazendo backup do Traefik..."

    local backup_dir="/tmp/traefik-backup-$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"

    # Backup de volumes
    docker inspect "$traefik_name" --format '{{range .Mounts}}{{.Source}} {{.Destination}}{{"\n"}}{{end}}' 2>/dev/null | while read mount; do
        if [ ! -z "$mount" ]; then
            local source=$(echo "$mount" | awk '{print $1}')
            local dest=$(echo "$mount" | awk '{print $2}')

            if [ -f "$source" ]; then
                cp "$source" "$backup_dir/" 2>/dev/null || true
            elif [ -d "$source" ]; then
                cp -r "$source" "$backup_dir/" 2>/dev/null || true
            fi
        fi
    done

    # Backup configura√ß√£o do container
    docker inspect "$traefik_name" > "$backup_dir/traefik_config.json" 2>/dev/null || true

    echo "$backup_dir" > /tmp/traefik_backup_path
    log_success "‚úÖ Backup do Traefik salvo em: $backup_dir"
}

# Corrigir Traefik em stack
fix_traefik_in_stack() {
    local traefik_container="$1"

    log_fix "üîß Corrigindo Traefik em stack..."

    # Obter stack do Traefik
    local stack_name=$(docker inspect "$traefik_container" --format '{{.Config.Labels}}' | grep -o 'com.docker.compose.project:[^,}]*' | cut -d':' -f2 | tr -d ' "')

    if [ ! -z "$stack_name" ]; then
        log_info "Stack detectada: $stack_name"

        # Tentar reiniciar stack inteira
        log_fix "Reiniciando stack $stack_name..."

        # Parar containers da stack
        docker ps --filter "label=com.docker.compose.project=$stack_name" --format "{{.Names}}" | while read container; do
            if [ ! -z "$container" ]; then
                docker stop "$container" 2>/dev/null || true
            fi
        done

        sleep 5

        # Reiniciar containers da stack
        docker ps -a --filter "label=com.docker.compose.project=$stack_name" --format "{{.Names}}" | while read container; do
            if [ ! -z "$container" ]; then
                docker start "$container" 2>/dev/null || true
            fi
        done

        sleep 15

        # Verificar se Traefik est√° funcionando agora
        if timeout 10 curl -s http://localhost:8080/api/overview > /dev/null 2>&1; then
            log_success "‚úÖ Traefik em stack corrigido!"
        else
            log_warning "‚ö†Ô∏è Traefik ainda com problemas na stack"
        fi
    fi
}

# Corre√ß√£o comprehensive do Traefik
fix_traefik_comprehensive() {
    local traefik_name="$1"

    log_fix "üõ†Ô∏è Aplicando corre√ß√£o comprehensive do Traefik..."

    # Executar todas as corre√ß√µes em sequ√™ncia
    fix_traefik_port_conflict "$traefik_name"
    fix_traefik_file_permissions "$traefik_name"
    fix_traefik_ssl_issues "$traefik_name"

    # Aguardar estabiliza√ß√£o
    sleep 20

    # Verificar resultados
    local dashboard_ok=false
    local proxy_ok=false
    local ssl_ok=false

    # Testar dashboard
    if timeout 10 curl -s http://localhost:8080/api/overview > /dev/null 2>&1; then
        dashboard_ok=true
        log_success "‚úÖ Dashboard funcionando"
    fi

    # Testar proxy
    if timeout 10 curl -s http://localhost:80 > /dev/null 2>&1; then
        proxy_ok=true
        log_success "‚úÖ Proxy funcionando"
    fi

    # Testar SSL (se aplic√°vel)
    if timeout 10 curl -sk https://localhost:443 > /dev/null 2>&1; then
        ssl_ok=true
        log_success "‚úÖ SSL funcionando"
    fi

    # Relat√≥rio final
    local issues_fixed=0
    [ "$dashboard_ok" = true ] && issues_fixed=$((issues_fixed + 1))
    [ "$proxy_ok" = true ] && issues_fixed=$((issues_fixed + 1))
    [ "$ssl_ok" = true ] && issues_fixed=$((issues_fixed + 1))

    if [ $issues_fixed -ge 2 ]; then
        log_success "üéâ Traefik majoritariamente corrigido! ($issues_fixed/3 funcionalidades OK)"
    else
        log_warning "‚ö†Ô∏è Traefik ainda com problemas significativos ($issues_fixed/3 funcionalidades OK)"

        # Se ainda h√° muitos problemas, sugerir recria√ß√£o completa
        suggest_traefik_recreation "$traefik_name"
    fi
}

# Sugerir recria√ß√£o completa do Traefik
suggest_traefik_recreation() {
    local traefik_name="$1"

    log_warning "üîÑ Traefik com problemas persistentes"
    log_info "üí° Ser√° criado um novo Traefik otimizado no deploy principal"
    log_info "üìù O Traefik problem√°tico ser√° parado para evitar conflitos"

    # Parar Traefik problem√°tico
    docker stop "$traefik_name" 2>/dev/null || true

    # Marcar para n√£o iniciar automaticamente
    docker update --restart=no "$traefik_name" 2>/dev/null || true

    log_success "‚úÖ Traefik problem√°tico desabilitado - novo Traefik ser√° criado"
}

# Verifica√ß√£o final de conflitos entre Traefiks
check_traefik_conflicts_final() {
    log_info "üîç Verifica√ß√£o final de conflitos entre Traefiks..."

    # Listar todos os containers Traefik
    local all_traefiks=$(docker ps -a --filter "name=traefik" --format "{{.Names}}" 2>/dev/null)
    local running_traefiks=$(docker ps --filter "name=traefik" --format "{{.Names}}" 2>/dev/null)

    local traefik_count=$(echo "$running_traefiks" | grep -v '^$' | wc -l)

    realtime_echo "${CYAN}üìä Status dos Traefiks:${NC}"
    realtime_echo "   ‚Ä¢ Total detectados: $(echo "$all_traefiks" | grep -v '^$' | wc -l)"
    realtime_echo "   ‚Ä¢ Rodando: $traefik_count"

    if [ $traefik_count -gt 1 ]; then
        log_warning "ÔøΩÔøΩÔøΩÔ∏è M√∫ltiplos Traefiks rodando - resolvendo conflitos..."

        echo "$running_traefiks" | while read traefik; do
            if [ ! -z "$traefik" ]; then
                # Verificar se √© o Traefik novo (do nosso deploy)
                if echo "$traefik" | grep -q "siqueira-traefik"; then
                    log_success "‚úÖ Mantendo Traefik novo: $traefik"
                else
                    log_fix "üîß Parando Traefik antigo: $traefik"
                    docker stop "$traefik" 2>/dev/null || true
                    docker update --restart=no "$traefik" 2>/dev/null || true
                fi
            fi
        done

        sleep 10

        # Verificar novamente
        local final_running=$(docker ps --filter "name=traefik" --format "{{.Names}}" | wc -l)

        if [ $final_running -eq 1 ]; then
            log_success "‚úÖ Conflito resolvido - apenas 1 Traefik rodando"
        else
            log_warning "‚ö†Ô∏è Ainda h√° $final_running Traefiks rodando"
        fi
    elif [ $traefik_count -eq 1 ]; then
        log_success "‚úÖ Apenas 1 Traefik rodando - sem conflitos"

        # Verificar se √© o nosso Traefik
        if echo "$running_traefiks" | grep -q "siqueira-traefik"; then
            log_success "‚úÖ Traefik do deploy funcionando"

            # Testar funcionalidades
            test_final_traefik_functionality
        else
            log_info "‚ÑπÔ∏è Traefik externo rodando"
        fi
    else
        log_warning "‚ö†Ô∏è Nenhum Traefik rodando"
    fi
}

# Testar funcionalidade final do Traefik
test_final_traefik_functionality() {
    log_info "üß™ Testando funcionalidades do Traefik final..."

    local tests_passed=0
    local total_tests=4

    # Teste 1: Dashboard
    if timeout 10 curl -s http://localhost:8080/api/overview > /dev/null 2>&1; then
        log_success "‚úÖ Dashboard: Funcionando"
        tests_passed=$((tests_passed + 1))
    else
        log_warning "‚ùå Dashboard: N√£o acess√≠vel"
    fi

    # Teste 2: Proxy HTTP
    if timeout 10 curl -s http://localhost:80 > /dev/null 2>&1; then
        local http_response=$(timeout 5 curl -s -o /dev/null -w "%{http_code}" http://localhost:80 2>/dev/null)
        if [ "$http_response" != "502" ] && [ "$http_response" != "503" ] && [ "$http_response" != "504" ]; then
            log_success "‚úÖ Proxy HTTP: Funcionando ($http_response)"
            tests_passed=$((tests_passed + 1))
        else
            log_warning "‚ùå Proxy HTTP: Erro Gateway ($http_response)"
        fi
    else
        log_warning "‚ùå Proxy HTTP: N√£o acess√≠vel"
    fi

    # Teste 3: HTTPS (se aplic√°vel)
    if timeout 10 curl -sk https://localhost:443 > /dev/null 2>&1; then
        log_success "‚úÖ HTTPS: Funcionando"
        tests_passed=$((tests_passed + 1))
    else
        log_warning "‚ö†Ô∏è HTTPS: N√£o configurado/acess√≠vel (normal se n√£o h√° dom√≠nio)"
    fi

    # Teste 4: Conectividade com containers
    if docker exec siqueira-traefik nslookup siqueira-app > /dev/null 2>&1; then
        log_success "‚úÖ Conectividade interna: OK"
        tests_passed=$((tests_passed + 1))
    else
        log_warning "‚ùå Conectividade interna: Problemas"
    fi

    # Resultado final
    local success_rate=$((tests_passed * 100 / total_tests))

    realtime_echo ""
    realtime_echo "${CYAN}üìä Resultado dos testes do Traefik:${NC}"
    realtime_echo "   ‚Ä¢ Testes passados: $tests_passed/$total_tests"
    realtime_echo "   ‚Ä¢ Taxa de sucesso: ${success_rate}%"

    if [ $success_rate -ge 75 ]; then
        realtime_echo "   ‚úÖ Traefik funcionando adequadamente!"
    elif [ $success_rate -ge 50 ]; then
        realtime_echo "   ‚ö†Ô∏è Traefik com funcionalidade limitada"
    else
        realtime_echo "   ‚ùå Traefik com problemas significativos"

        # Logs para diagn√≥stico
        realtime_echo ""
        realtime_echo "${YELLOW}üìã Logs recentes do Traefik para diagn√≥stico:${NC}"
        docker logs --tail=10 siqueira-traefik 2>/dev/null | head -5 || true
    fi
}

# Verificar recursos do sistema
check_system_resources() {
    log_info "üíª Verificando recursos do sistema..."

    # Verificar RAM
    local ram_total=$(free -m | awk 'NR==2{print $2}')
    local ram_available=$(free -m | awk 'NR==2{print $7}')

    if [ $ram_total -lt 1000 ]; then
        log_warning "‚ö†Ô∏è RAM baixa: ${ram_total}MB total"
    fi

    if [ $ram_available -lt 500 ]; then
        log_warning "‚ö†Ô∏è RAM dispon√≠vel baixa: ${ram_available}MB"
        log_fix "Liberando cache..."
        sudo sync && echo 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null || true
    fi

    # Verificar CPU load
    local cpu_load=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
    local cpu_cores=$(nproc)

    if (( $(echo "$cpu_load > $cpu_cores" | bc -l 2>/dev/null || echo 0) )); then
        log_warning "‚ö†Ô∏è Alta carga de CPU: $cpu_load (cores: $cpu_cores)"
    fi

    # Verificar swap
    local swap_used=$(free -m | awk 'NR==3{print $3}')
    if [ $swap_used -gt 1000 ]; then
        log_warning "‚ö†Ô∏è Alto uso de swap: ${swap_used}MB"
    fi

    log_success "‚úÖ Recursos do sistema verificados"
}

# Fun√ß√£o para manter processo vivo com monitoramento
keep_alive() {
    while true; do
        sleep 30

        # Verificar se processo ainda est√° rodando
        if ! ps -p $$ > /dev/null; then
            break
        fi

        # Monitoramento proativo
        monitor_system_health
    done &
}

# Monitoramento proativo da sa√∫de do sistema
monitor_system_health() {
    # Verificar se Docker ainda est√° rodando
    if ! docker ps &> /dev/null; then
        log_warning "üîÑ Docker parou. Reiniciando..."
        sudo systemctl restart docker 2>/dev/null || true
    fi

    # Verificar espa√ßo em disco cr√≠tico
    local available_space=$(df / | awk 'NR==2 {print $4}')
    local available_gb=$((available_space / 1024 / 1024))

    if [ $available_gb -lt 1 ]; then
        log_warning "üßπ Espa√ßo cr√≠tico. Limpando automaticamente..."
        docker system prune -f 2>/dev/null || true
        sudo journalctl --vacuum-time=1d 2>/dev/null || true
    fi
}

# Fun√ß√£o avan√ßada de retry com backoff exponencial
retry_with_backoff() {
    local cmd="$1"
    local desc="$2"
    local max_attempts="${3:-5}"
    local base_delay="${4:-2}"

    local attempt=1
    local delay=$base_delay

    while [ $attempt -le $max_attempts ]; do
        log_info "Tentativa $attempt/$max_attempts: $desc"

        if eval "$cmd"; then
            log_success "‚úÖ $desc - Sucesso na tentativa $attempt"
            return 0
        else
            if [ $attempt -lt $max_attempts ]; then
                log_warning "‚ö†Ô∏è Tentativa $attempt falhou. Aguardando ${delay}s..."
                sleep $delay
                delay=$((delay * 2))  # Backoff exponencial

                # Auto-diagn√≥stico entre tentativas
                case $desc in
                    *"Docker"*|*"docker"*)
                        log_fix "Verificando Docker entre tentativas..."
                        check_and_fix_docker
                        ;;
                    *"conectividade"*|*"download"*)
                        log_fix "Verificando conectividade..."
                        ping -c 1 8.8.8.8 &> /dev/null || log_warning "Conectividade inst√°vel"
                        ;;
                esac
            fi
        fi

        attempt=$((attempt + 1))
    done

    log_error "‚ùå $desc - Falhou ap√≥s $max_attempts tentativas"
    return 1
}

# Fun√ß√£o simplificada para output em tempo real
realtime_echo() {
    local message="$1"

    # Output simples que funciona sempre
    echo -e "$message" 2>/dev/null || echo "$message"

    # Salvar no log se arquivo existe
    if [[ -n "${LOG_FILE:-}" ]]; then
        echo -e "$message" >> "$LOG_FILE" 2>/dev/null || true
    fi

    # Micro pausa para sincroniza√ß√£o
    sleep 0.02
}

# Fun√ß√£o para progress bar
show_progress() {
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local completed=$((current * width / total))

    printf "\r${BLUE}[INFO]${NC} Progresso: ["
    printf "%*s" "$completed" | tr ' ' '='
    printf "%*s" $((width - completed)) | tr ' ' '-'
    printf "] %d%% (%d/%d)" "$percentage" "$current" "$total"

    if [ "$current" -eq "$total" ]; then
        echo ""
    fi
}

# ============= CORES =============
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m'

clear
realtime_echo "${PURPLE}ÔøΩÔøΩÔøΩÔøΩ =========================================="
realtime_echo "üöÄ MEGA DEPLOY AUTOM√ÅTICO V3 - TEMPO REAL"
realtime_echo "üè† Siqueira Campos Im√≥veis"
realtime_echo "üî• APAGA TUDO E REFAZ + LOGS EM TEMPO REAL"
realtime_echo "üè† ==========================================${NC}"

# ============= FUN√á√ïES DE LOG V3 =============
log_info() {
    realtime_echo "${BLUE}[INFO]${NC} $1"
}

log_success() {
    realtime_echo "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    realtime_echo "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    realtime_echo "${RED}[ERROR]${NC} $1"
}

log_fix() {
    realtime_echo "${CYAN}[FIX]${NC} $1"
}

log_step() {
    realtime_echo "${WHITE}[STEP $1/$2]${NC} $3"
}

# Fun√ß√£o ultra-robusta para executar comandos com auto-corre√ß√£o
run_with_progress() {
    local cmd="$1"
    local desc="$2"
    local timeout_duration="${3:-300}"
    local retry_attempts="${4:-3}"

    log_info "üöÄ Executando: $desc"

    # Fun√ß√£o interna para executar com timeout
    _execute_cmd() {
        local temp_output=$(mktemp)
        local start_time=$(date +%s)

        set +e
        timeout "$timeout_duration" bash -c "$cmd" > "$temp_output" 2>&1
        local exit_code=$?
        set -o pipefail

        if [ $exit_code -eq 0 ]; then
            if [[ -s "$temp_output" ]]; then
                realtime_echo "${BLUE}‚úÖ Output:${NC}"
                head -3 "$temp_output" 2>/dev/null || true
            fi

            local end_time=$(date +%s)
            local duration=$((end_time - start_time))
            log_success "$desc - Conclu√≠do em ${duration}s"
            rm -f "$temp_output" 2>/dev/null || true
            return 0
        else
            # An√°lise inteligente do erro
            local error_output=$(cat "$temp_output" 2>/dev/null)
            rm -f "$temp_output" 2>/dev/null || true

            # Auto-diagn√≥stico e corre√ß√£o baseada no erro
            auto_diagnose_and_fix "$error_output" "$cmd" "$desc"

            return $exit_code
        fi
    }

    # Tentar com sistema de retry avan√ßado
    if retry_with_backoff "_execute_cmd" "$desc" "$retry_attempts"; then
        return 0
    else
        log_warning "‚ö†Ô∏è $desc - Falhou mas CONTINUANDO o deploy..."
        return 0  # Sempre continuar
    fi
}

# Sistema de auto-diagn√≥stico e corre√ß√£o baseado em erros
auto_diagnose_and_fix() {
    local error_output="$1"
    local failed_cmd="$2"
    local desc="$3"

    realtime_echo "${YELLOW}üîç Analisando erro para auto-corre√ß√£o...${NC}"

    # An√°lise de padr√µes de erro comuns
    case "$error_output" in
        *"Permission denied"*|*"permission denied"*)
            log_fix "üîê Erro de permiss√£o detectado. Corrigindo..."
            check_and_fix_permissions
            ;;
        *"No space left"*|*"disk full"*)
            log_fix "üíæ Espa√ßo insuficiente. Liberando..."
            check_and_fix_disk_space
            ;;
        *"Connection refused"*|*"Network is unreachable"*)
            log_fix "üåê Problema de rede. Verificando conectividade..."
            ping -c 1 8.8.8.8 &> /dev/null || log_warning "Conectividade inst√°vel"
            ;;
        *"docker: command not found"*|*"Cannot connect to the Docker daemon"*)
            log_fix "üê≥ Problema no Docker. Corrigindo..."
            check_and_fix_docker
            ;;
        *"Port already in use"*|*"Address already in use"*)
            log_fix "üîå Porta ocupada. Resolvendo conflito..."
            check_and_fix_port_conflicts
            ;;
        *"package not found"*|*"command not found"*)
            log_fix "üì¶ Depend√™ncia em falta. Instalando..."
            check_and_fix_dependencies
            ;;
        *"Operation not permitted"*|*"Operation not supported"*)
            log_fix "üõ°Ô∏è Problema de sistema. Verificando..."
            check_system_resources
            ;;
        *"timeout"*|*"timed out"*)
            log_fix "‚è±Ô∏è Timeout detectado. Otimizando..."
            # Limpar cache DNS
            sudo systemctl restart systemd-resolved 2>/dev/null || true
            ;;
        *"certificate"*|*"SSL"*|*"TLS"*)
            log_fix "üîí Problema SSL/TLS. Corrigindo..."
            # Atualizar certificados
            sudo apt update && sudo apt install -y ca-certificates 2>/dev/null || true
            ;;
    esac

    # Auto-corre√ß√µes espec√≠ficas por comando
    case "$failed_cmd" in
        *"apt"*|*"apt-get"*)
            log_fix "üì¶ Problema no APT. Corrigindo..."
            sudo apt --fix-broken install -y 2>/dev/null || true
            sudo dpkg --configure -a 2>/dev/null || true
            ;;
        *"docker"*|*"docker-compose"*)
            log_fix "üê≥ Problema no Docker. Reset completo..."
            sudo systemctl restart docker 2>/dev/null || true
            sleep 5
            ;;
        *"curl"*|*"wget"*)
            log_fix "üåê Problema de download. Tentando alternativa..."
            if echo "$failed_cmd" | grep -q "curl"; then
                # Se curl falhou, tentar wget
                local alt_cmd=$(echo "$failed_cmd" | sed 's/curl/wget -O-/g')
                log_info "Tentando wget como alternativa..."
            fi
            ;;
    esac

    realtime_echo "${CYAN}üîß Auto-corre√ß√£o aplicada. Pronto para retry.${NC}"
}

# Fun√ß√£o melhorada para aguardar com countdown e monitoramento
wait_with_countdown() {
    local seconds=$1
    local message=$2

    log_info "$message"
    for ((i=seconds; i>0; i--)); do
        printf "\r${YELLOW}Aguardando... %d segundos restantes${NC}" "$i"

        # For√ßar flush do output
        printf "\033[0m" > /dev/tty 2>/dev/null || true

        sleep 1
    done
    echo ""
}

# Fun√ß√£o para monitorar processos em tempo real
monitor_processes() {
    local service_name="$1"
    local max_wait="${2:-60}"

    log_info "üîç Monitorando $service_name por at√© ${max_wait}s..."

    for ((i=1; i<=max_wait; i++)); do
        # Verificar se container existe e est√° rodando
        local status=$(docker-compose ps --filter status=running --services | grep "$service_name" || echo "")

        if [[ -n "$status" ]]; then
            log_success "‚úÖ $service_name est√° rodando!"
            return 0
        fi

        printf "\r${CYAN}Aguardando $service_name... %d/%ds${NC}" "$i" "$max_wait"
        sleep 1
    done

    echo ""
    log_warning "‚ö†Ô∏è $service_name ainda n√£o est√° rodando ap√≥s ${max_wait}s"
    return 1
}

# ============= CONFIGURA√á√ïES FIXAS =============
DOMAIN="siqueicamposimoveis.com.br"
DOMAIN2=""  # Ser√° configurado automaticamente ou via input
EMAIL="admin@siqueicamposimoveis.com.br"
TOTAL_STEPS=15

# Auto-detectar segundo dom√≠nio se existir
detect_second_domain() {
    # Verificar se j√° existe um Portainer com dom√≠nio diferente
    local existing_domains=$(docker ps --format "table {{.Names}}\t{{.Labels}}" | grep -E "traefik.*Host" | grep -v "$DOMAIN" | head -1)

    if [ ! -z "$existing_domains" ]; then
        local detected_domain=$(echo "$existing_domains" | grep -oP 'Host\\(\`[^`]+' | head -1 | sed 's/Host\\(`//g')
        if [ ! -z "$detected_domain" ] && [ "$detected_domain" != "$DOMAIN" ]; then
            DOMAIN2="$detected_domain"
            log_info "üîç Segundo dom√≠nio detectado automaticamente: $DOMAIN2"
        fi
    fi
}

# Detectar automaticamente segundo dom√≠nio
detect_second_domain

# Inicializar processo keep-alive
keep_alive

log_success "ü§ñ MODO MEGA AUTOM√ÅTICO V3 ATIVADO!"
log_info "   Dom√≠nio: $DOMAIN"
log_info "   Email: $EMAIL"
log_info "   Modo: Traefik + SSL + Docker + Auto-Fix + Logs Tempo Real"
log_info "   Log File: $LOG_FILE"
log_info "   PID: $$"
log_info "   Terminal: $(tty 2>/dev/null || echo 'detached')"

# Detectar sistema
if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
    log_error "Execute este script no VPS Linux, n√£o no Windows!"
    exit 1
fi

# ============= PASSO 0: SISTEMA ULTRA-ROBUSTO DE AUTO-CORRE√á√ÉO =============
log_step 0 $TOTAL_STEPS "Sistema ultra-robusto de auto-corre√ß√£o"

realtime_echo "${PURPLE}ü§ñ INICIANDO SISTEMA DE AUTO-CORRE√á√ÉO AVAN√áADO...${NC}"

# Executar sistema completo de auto-corre√ß√£o
auto_fix_system

log_info "üîç Verificando usu√°rio atual..."
if [[ $EUID -eq 0 ]]; then
   log_error "Este script n√£o deve ser executado como root"
   exit 1
fi
log_success "Usu√°rio n√£o-root confirmado"

log_info "üîç Verificando conectividade..."

# Testar conectividade de forma simples
if ping -c 1 -W 3 8.8.8.8 &> /dev/null || ping -c 1 -W 3 google.com &> /dev/null; then
    log_success "Conectividade OK"
else
    log_warning "Conectividade limitada - continuando mesmo assim..."
fi

log_info "üîç Verificando porta 80..."
PORT_80_CHECK=$(sudo netstat -tlnp | grep :80 | head -1 || true)
if [ ! -z "$PORT_80_CHECK" ]; then
    log_warning "Porta 80 est√° ocupada:"
    realtime_echo "$PORT_80_CHECK"
    log_fix "Liberando porta 80 automaticamente..."

    # Parar Apache se existir
    if systemctl is-active --quiet apache2 2>/dev/null; then
        log_fix "Parando Apache..."
        run_with_progress "sudo systemctl stop apache2 && sudo systemctl disable apache2" "Parar Apache"
    fi

    # Parar Nginx se existir
    if systemctl is-active --quiet nginx 2>/dev/null; then
        log_fix "Parando Nginx..."
        run_with_progress "sudo systemctl stop nginx && sudo systemctl disable nginx" "Parar Nginx"
    fi

    # Verificar novamente
    PORT_80_CHECK_AFTER=$(sudo netstat -tlnp | grep :80 | head -1 || true)
    if [ ! -z "$PORT_80_CHECK_AFTER" ]; then
        log_warning "Porta 80 ainda ocupada. Usando portas alternativas..."
        USE_ALT_PORTS=true
    else
        log_success "Porta 80 liberada com sucesso!"
        USE_ALT_PORTS=false
    fi
else
    log_success "Porta 80 dispon√≠vel!"
    USE_ALT_PORTS=false
fi

show_progress 1 $TOTAL_STEPS

# ============= PASSO 1: LIMPEZA TOTAL =============
log_step 1 $TOTAL_STEPS "Limpeza total do sistema Docker"

log_warning "üî• LIMPANDO TUDO - RESET COMPLETO..."

log_info "Parando containers..."
run_with_progress "docker stop \$(docker ps -aq) 2>/dev/null || true" "Parar containers"

log_info "Removendo containers..."
run_with_progress "docker rm \$(docker ps -aq) 2>/dev/null || true" "Remover containers"

log_info "Removendo imagens..."
run_with_progress "docker rmi \$(docker images -aq) 2>/dev/null || true" "Remover imagens"

log_info "Removendo volumes..."
run_with_progress "docker volume rm \$(docker volume ls -q) 2>/dev/null || true" "Remover volumes"

log_info "Removendo redes..."
run_with_progress "docker network rm \$(docker network ls --filter type=custom -q) 2>/dev/null || true" "Remover redes"

log_info "Limpeza total do sistema Docker..."
run_with_progress "docker system prune -af --volumes 2>/dev/null || true" "System prune"

log_success "‚úÖ LIMPEZA TOTAL CONCLU√çDA!"
show_progress 2 $TOTAL_STEPS

# ============= PASSO 2: INSTALA√á√ÉO AUTOM√ÅTICA =============
log_step 2 $TOTAL_STEPS "Instala√ß√£o de depend√™ncias"

log_info "üì¶ Instalando depend√™ncias automaticamente..."

log_info "Atualizando sistema..."
run_with_progress "sudo apt update && sudo apt upgrade -y" "Atualizar sistema"

log_info "Instalando depend√™ncias b√°sicas..."
run_with_progress "sudo apt install -y curl wget git unzip htop nano ufw" "Depend√™ncias b√°sicas"

# Instalar Docker se necess√°rio
if ! command -v docker &> /dev/null; then
    log_info "Instalando Docker..."
    run_with_progress "curl -fsSL https://get.docker.com -o get-docker.sh" "Download Docker script"
    run_with_progress "sudo sh get-docker.sh" "Instalar Docker"
    run_with_progress "sudo usermod -aG docker \$USER" "Adicionar usu√°rio ao grupo Docker"
    run_with_progress "rm get-docker.sh" "Limpar script"
else
    log_success "Docker j√° instalado"
fi

# Instalar Docker Compose
if ! command -v docker-compose &> /dev/null; then
    log_info "Instalando Docker Compose..."
    run_with_progress "sudo curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-\$(uname -s)-\$(uname -m)\" -o /usr/local/bin/docker-compose" "Download Docker Compose"
    run_with_progress "sudo chmod +x /usr/local/bin/docker-compose" "Tornar execut√°vel"
else
    log_success "Docker Compose j√° instalado"
fi

log_success "‚úÖ Todas as depend√™ncias instaladas!"
show_progress 3 $TOTAL_STEPS

# ============= PASSO 3: GERAR SENHAS =============
log_step 3 $TOTAL_STEPS "Gera√ß√£o de senhas seguras"

log_info "üîê Gerando senhas seguras automaticamente..."

DB_PASSWORD=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)
JWT_SECRET=$(openssl rand -base64 64 | tr -d "=+/" | cut -c1-50)
COOKIE_SECRET=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-30)
N8N_PASSWORD=$(openssl rand -base64 16 | tr -d "=+/" | cut -c1-12)
EVOLUTION_KEY=$(openssl rand -base64 32 | tr -d "=+/" | cut -c1-25)

log_success "‚úÖ Senhas geradas!"
show_progress 4 $TOTAL_STEPS

# ============= PASSO 4: CRIAR .ENV =============
log_step 4 $TOTAL_STEPS "Cria√ß√£o do arquivo .env"

log_info "‚öôÔ∏è Criando configura√ß√£o autom√°tica..."

cat > .env <<EOF
# MEGA DEPLOY AUTOM√ÅTICO V3 - Siqueira Campos Im√≥veis
NODE_ENV=production
DOMAIN=$DOMAIN
EMAIL=$EMAIL

# Banco PostgreSQL
DATABASE_URL=postgresql://sitejuarez:$DB_PASSWORD@postgres:5432/bdsitejuarez?schema=public
POSTGRES_DB=bdsitejuarez
POSTGRES_USER=sitejuarez
POSTGRES_PASSWORD=$DB_PASSWORD

# Redis
REDIS_HOST=redis
REDIS_PORT=6379

# JWT & Security
JWT_SECRET=$JWT_SECRET
JWT_EXPIRES_IN=7d
COOKIE_SECRET=$COOKIE_SECRET

# Email SMTP
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=siqueiraecamposimoveisgoiania@gmail.com
EMAIL_PASS=Juarez.123

# Google OAuth
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
GOOGLE_CALLBACK_URL=https://$DOMAIN/api/auth/google/callback

# N8N
N8N_BASIC_AUTH_USER=admin
N8N_BASIC_AUTH_PASSWORD=$N8N_PASSWORD

# Evolution API
EVOLUTION_API_KEY=$EVOLUTION_KEY

# OpenAI
OPENAI_API_KEY=

# Timezone
TZ=America/Sao_Paulo

# Configura√ß√£o de portas
USE_ALT_PORTS=$USE_ALT_PORTS
EOF

log_success "‚úÖ Arquivo .env criado!"
show_progress 5 $TOTAL_STEPS

# ============= PASSO 5: CRIAR PACKAGE.JSON =============
log_step 5 $TOTAL_STEPS "Cria√ß√£o do package.json"

cat > package.json <<EOF
{
  "name": "siqueira-campos-imoveis",
  "version": "3.0.0",
  "description": "Sistema imobili√°rio premium com automa√ß√£o completa V3",
  "type": "module",
  "scripts": {
    "dev": "node server.js",
    "build": "echo 'Build completed V3'",
    "start": "node server.js",
    "db:migrate": "echo 'Migra√ß√µes OK'",
    "db:seed": "echo 'Seed OK'"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
EOF

log_success "‚úÖ package.json criado!"
show_progress 6 $TOTAL_STEPS

# ============= PASSO 6: CRIAR SERVIDOR EXPRESS =============
log_step 6 $TOTAL_STEPS "Cria√ß√£o do servidor Express"

log_info "üåê Criando servidor Express V3..."

cat > server.js <<'EOF'
import express from 'express';
import cors from 'cors';

const app = express();
const PORT = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Log de todas as requisi√ß√µes
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

// API Routes
app.get('/api/ping', (req, res) => {
  const response = {
    message: "üè† Siqueira Campos Im√≥veis V3 - Online!",
    timestamp: new Date().toISOString(),
    deploy: "Mega Deploy Autom√°tico V3 - Logs Tempo Real",
    status: "success",
    version: "3.0.0",
    uptime: process.uptime(),
    memory: process.memoryUsage()
  };
  console.log('Ping recebido:', response);
  res.json(response);
});

app.get('/api/health', (req, res) => {
  res.json({
    status: "healthy",
    version: "3.0.0",
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

app.get('/api/demo', (req, res) => {
  res.json({
    empresa: "Siqueira Campos Im√≥veis",
    status: "online",
    deploy: "Mega Deploy Autom√°tico V3",
    servicos: ["vendas", "locacao", "administracao"],
    contato: "(62) 9 8556-3505",
    whatsapp: "https://wa.me/5562985563505",
    features: ["Traefik", "SSL", "Docker", "N8N", "WhatsApp Business", "Auto-Fix", "Logs Tempo Real"],
    version: "3.0.0"
  });
});

// P√°gina inicial V3
app.get('/', (req, res) => {
  res.send(`
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üè† Siqueira Campos Im√≥veis V3</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 50%, #CD853F 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            text-align: center;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .logo h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .version-badge {
            background: rgba(255,215,0,0.3);
            border: 2px solid #FFD700;
            border-radius: 25px;
            padding: 12px 20px;
            display: inline-block;
            margin: 15px;
            font-size: 1.1em;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .status {
            background: rgba(76, 175, 80, 0.2);
            border: 2px solid #4CAF50;
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
            backdrop-filter: blur(5px);
        }
        .status h3 { color: #4CAF50; margin-bottom: 15px; font-size: 1.5em; }
        .realtime-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #4CAF50;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }
        .tech-stack {
            background: rgba(0,0,0,0.2);
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
        }
        .new-features {
            background: rgba(255,215,0,0.1);
            border: 2px solid #FFD700;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
        }
        .new-features h3 { color: #FFD700; margin-bottom: 15px; }
        .feature-list {
            text-align: left;
            max-width: 600px;
            margin: 0 auto;
        }
        .feature-list li {
            margin: 8px 0;
            padding-left: 25px;
            position: relative;
        }
        .feature-list li:before {
            content: "üöÄ";
            position: absolute;
            left: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">
            <h1>üè† Siqueira Campos Im√≥veis</h1>
            <p>Seu parceiro ideal no mercado imobili√°rio</p>
            <div class="version-badge">
                <span class="realtime-indicator"></span>
                V3.0.0 - Logs Tempo Real
            </div>
        </div>

        <div class="status">
            <h3>‚úÖ Sistema Online - Mega Deploy V3!</h3>
            <p><strong>üöÄ Traefik + Let's Encrypt + Docker + Logs em Tempo Real</strong></p>
            <p>Deploy realizado com sucesso em modo totalmente autom√°tico com monitoramento</p>
        </div>

        <div class="new-features">
            <h3>üÜï Novidades V3 - Logs Tempo Real</h3>
            <ul class="feature-list">
                <li><strong>Logs em Tempo Real:</strong> Acompanhe todo o processo de deploy</li>
                <li><strong>Progress Bar:</strong> Visualize o progresso da instala√ß√£o</li>
                <li><strong>Cleanup Autom√°tico:</strong> Tratamento de interrup√ß√µes</li>
                <li><strong>Health Checks:</strong> Monitoramento cont√≠nuo dos servi√ßos</li>
                <li><strong>Retry Logic:</strong> Tentativas autom√°ticas em caso de falha</li>
                <li><strong>Conectividade Check:</strong> Verifica√ß√£o de internet</li>
            </ul>
        </div>

        <div id="status-info" class="tech-stack">
            <h3>üìä Status do Sistema</h3>
            <p>Carregando informa√ß√µes...</p>
        </div>
    </div>

    <script>
        // Atualizar status em tempo real
        async function updateStatus() {
            try {
                const response = await fetch('/api/ping');
                const data = await response.json();

                document.getElementById('status-info').innerHTML = \`
                    <h3>üìä Status do Sistema V3</h3>
                    <p><strong>Status:</strong> \${data.status}</p>
                    <p><strong>Uptime:</strong> \${Math.floor(data.uptime)} segundos</p>
                    <p><strong>Vers√£o:</strong> \${data.version}</p>
                    <p><strong>√öltima atualiza√ß√£o:</strong> \${new Date(data.timestamp).toLocaleString()}</p>
                \`;

                console.log('‚úÖ Status atualizado:', data);
            } catch (error) {
                console.error('‚ùå Erro ao atualizar status:', error);
                document.getElementById('status-info').innerHTML = \`
                    <h3>üìä Status do Sistema</h3>
                    <p style="color: #ff6b6b;">‚ùå Erro ao conectar com a API</p>
                \`;
            }
        }

        // Atualizar a cada 10 segundos
        updateStatus();
        setInterval(updateStatus, 10000);

        // Ping peri√≥dico
        setInterval(() => {
            fetch('/api/health')
                .then(res => res.json())
                .then(data => console.log('üíó Health check:', data))
                .catch(err => console.log('üíî Health check failed:', err));
        }, 30000);
    </script>
</body>
</html>
  `);
});

// SPA fallback
app.get('*', (req, res) => {
  if (req.path.startsWith('/api/')) {
    res.status(404).json({ error: "API endpoint not found", version: "3.0.0" });
  } else {
    res.redirect('/');
  }
});

// Tratamento de sinais para graceful shutdown
process.on('SIGTERM', () => {
  console.log('üõë SIGTERM recebido, fechando servidor...');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('üõë SIGINT recebido, fechando servidor...');
  process.exit(0);
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`üè† Siqueira Campos Im√≥veis V3 rodando na porta ${PORT}`);
  console.log(`üåê URL: http://localhost:${PORT}`);
  console.log(`üöÄ Mega Deploy Autom√°tico V3 - Logs Tempo Real!`);
  console.log(`üìä Status: ONLINE | Modo: Produ√ß√£o | Version: 3.0.0`);
  console.log(`üìù PID: ${process.pid} | Memory: ${JSON.stringify(process.memoryUsage())}`);
});
EOF

log_success "‚úÖ Servidor Express V3 criado!"
show_progress 7 $TOTAL_STEPS

# ============= PASSO 7: CRIAR DOCKERFILE =============
log_step 7 $TOTAL_STEPS "Cria√ß√£o do Dockerfile"

cat > Dockerfile <<'EOF'
FROM node:18-alpine

# Instalar depend√™ncias para healthcheck
RUN apk add --no-cache curl dumb-init

WORKDIR /app

# Copiar e instalar depend√™ncias
COPY package*.json ./
RUN npm install

# Copiar aplica√ß√£o
COPY . .

# Criar usu√°rio n√£o-root
RUN addgroup -g 1001 -S nodejs && \
    adduser -S fusion -u 1001 && \
    chown -R fusion:nodejs /app

USER fusion

EXPOSE 3000

# Healthcheck melhorado
HEALTHCHECK --interval=15s --timeout=5s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:3000/api/health || exit 1

# Usar dumb-init para melhor handling de sinais
ENTRYPOINT ["dumb-init", "--"]
CMD ["npm", "start"]
EOF

log_success "‚úÖ Dockerfile criado!"
show_progress 8 $TOTAL_STEPS

# ============= PASSO 8: CRIAR DOCKER-COMPOSE =============
log_step 8 $TOTAL_STEPS "Cria√ß√£o do docker-compose.yml"

if [ "$USE_ALT_PORTS" = true ]; then
    log_fix "Usando portas alternativas (8000/8443) para evitar conflitos..."
    HTTP_PORT="8000"
    HTTPS_PORT="8443"
else
    log_info "Usando portas padr√£o (80/443)..."
    HTTP_PORT="80"
    HTTPS_PORT="443"
fi

# Criar docker-compose com healthchecks melhorados
cat > docker-compose.yml <<EOF
services:
  traefik:
    image: traefik:v3.0
    container_name: siqueira-traefik
    restart: unless-stopped
    ports:
      - "$HTTP_PORT:80"
      - "$HTTPS_PORT:443"
      - "8080:8080"
    command:
      - --api.dashboard=true
      - --api.insecure=true
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --providers.docker=true
      - --providers.docker.exposedbydefault=false
      - --providers.docker.network=siqueira-network
      - --certificatesresolvers.letsencrypt.acme.email=\${EMAIL}
      - --certificatesresolvers.letsencrypt.acme.storage=/acme.json
      - --certificatesresolvers.letsencrypt.acme.httpchallenge=true
      - --certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web
      - --log.level=INFO
      - --accesslog=true
      - --entrypoints.web.http.redirections.entrypoint.to=websecure
      - --entrypoints.web.http.redirections.entrypoint.scheme=https
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - traefik_acme:/acme.json
    networks:
      - siqueira-network
    healthcheck:
      test: ["CMD", "traefik", "healthcheck"]
      interval: 30s
      timeout: 10s
      retries: 3
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.traefik.rule=Host(\`traefik.\${DOMAIN}\`)"
      - "traefik.http.routers.traefik.entrypoints=websecure"
      - "traefik.http.routers.traefik.tls.certresolver=letsencrypt"
      - "traefik.http.routers.traefik.service=api@internal"

  postgres:
    image: postgres:15-alpine
    container_name: siqueira-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: \${POSTGRES_DB}
      POSTGRES_USER: \${POSTGRES_USER}
      POSTGRES_PASSWORD: \${POSTGRES_PASSWORD}
      TZ: \${TZ}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U \${POSTGRES_USER} -d \${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    networks:
      - siqueira-network

  redis:
    image: redis:7-alpine
    container_name: siqueira-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3
      start_period: 10s
    networks:
      - siqueira-network

  app:
    build: .
    container_name: siqueira-app
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      - NODE_ENV=production
      - DATABASE_URL=\${DATABASE_URL}
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - JWT_SECRET=\${JWT_SECRET}
      - JWT_EXPIRES_IN=\${JWT_EXPIRES_IN}
      - COOKIE_SECRET=\${COOKIE_SECRET}
      - TZ=\${TZ}
    volumes:
      - ./uploads:/app/uploads
      - app_logs:/app/logs
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    networks:
      - siqueira-network
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.app.rule=Host(\`\${DOMAIN}\`)"
      - "traefik.http.routers.app.entrypoints=websecure"
      - "traefik.http.routers.app.tls.certresolver=letsencrypt"
      - "traefik.http.services.app.loadbalancer.server.port=3000"

  portainer1:
    image: portainer/portainer-ce:latest
    container_name: siqueira-portainer1
    restart: unless-stopped
    ports:
      - "9001:9000"
      - "9444:9443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer1_data:/data
    networks:
      - siqueira-network
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.portainer1.rule=Host(\`portainer.\${DOMAIN}\`)"
      - "traefik.http.routers.portainer1.entrypoints=websecure"
      - "traefik.http.routers.portainer1.tls.certresolver=letsencrypt"
      - "traefik.http.services.portainer1.loadbalancer.server.port=9000"

  portainer2:
    image: portainer/portainer-ce:latest
    container_name: siqueira-portainer2
    restart: unless-stopped
    ports:
      - "9002:9000"
      - "9445:9443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer2_data:/data
    networks:
      - siqueira-network
    environment:
      - PORTAINER_OPTS=--admin-password-file=/data/admin_password
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.portainer2.rule=Host(\`portainer.\${DOMAIN2:-portainer2.local}\`)"
      - "traefik.http.routers.portainer2.entrypoints=websecure"
      - "traefik.http.routers.portainer2.tls.certresolver=letsencrypt"
      - "traefik.http.services.portainer2.loadbalancer.server.port=9000"

volumes:
  postgres_data:
  redis_data:
  app_logs:
  traefik_acme:
  portainer1_data:
  portainer2_data:

networks:
  siqueira-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
EOF

log_success "‚úÖ docker-compose.yml criado!"
show_progress 9 $TOTAL_STEPS

# ============= PASSO 9: CRIAR INIT.SQL =============
log_step 9 $TOTAL_STEPS "Cria√ß√£o do script de banco"

cat > init.sql <<EOF
-- Configura√ß√µes PostgreSQL para Siqueira Campos Im√≥veis V3
CREATE DATABASE n8n;
GRANT ALL PRIVILEGES ON DATABASE n8n TO sitejuarez;

-- Otimiza√ß√µes de performance
ALTER SYSTEM SET shared_preload_libraries = 'pg_stat_statements';
ALTER SYSTEM SET max_connections = 200;
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET effective_cache_size = '1GB';
ALTER SYSTEM SET maintenance_work_mem = '64MB';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;
ALTER SYSTEM SET wal_buffers = '16MB';
ALTER SYSTEM SET default_statistics_target = 100;
EOF

log_success "‚úÖ Script de banco criado!"
show_progress 10 $TOTAL_STEPS

# ============= PASSO 10: CONFIGURAR FIREWALL =============
log_step 10 $TOTAL_STEPS "Configura√ß√£o do firewall"

log_info "üîí Configurando firewall automaticamente..."
run_with_progress "sudo ufw --force reset" "Reset do firewall"
run_with_progress "sudo ufw allow 22/tcp" "Permitir SSH"
run_with_progress "sudo ufw allow 80/tcp" "Permitir HTTP"
run_with_progress "sudo ufw allow 443/tcp" "Permitir HTTPS"
run_with_progress "sudo ufw allow 8000/tcp" "Permitir HTTP alternativo"
run_with_progress "sudo ufw allow 8443/tcp" "Permitir HTTPS alternativo"
run_with_progress "sudo ufw allow 8080/tcp" "Permitir Traefik dashboard"
run_with_progress "sudo ufw --force enable" "Ativar firewall"

log_success "‚úÖ Firewall configurado!"
show_progress 11 $TOTAL_STEPS

# ============= PASSO 11: SISTEMA DE BACKUP E ROLLBACK =============
log_step 11 $TOTAL_STEPS "Sistema avan√ßado de backup e rollback"

# Criar backup completo antes do deploy
create_pre_deploy_backup() {
    log_info "üíæ Criando backup pr√©-deploy..."

    local backup_dir="/tmp/deploy-backup-$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"

    # Backup de configura√ß√µes existentes
    if [ -f "docker-compose.yml" ]; then
        cp docker-compose.yml "$backup_dir/" 2>/dev/null || true
    fi

    if [ -f ".env" ]; then
        cp .env "$backup_dir/" 2>/dev/null || true
    fi

    # Backup de dados de containers existentes
    if command -v docker-compose &> /dev/null && docker-compose ps &> /dev/null; then
        log_info "Fazendo backup de dados dos containers..."

        # Backup PostgreSQL se existir
        if docker-compose ps | grep -q postgres; then
            docker-compose exec -T postgres pg_dumpall -U postgres > "$backup_dir/postgres_backup.sql" 2>/dev/null || true
        fi

        # Backup de volumes
        docker-compose ps --services | while read service; do
            if [ ! -z "$service" ]; then
                docker-compose logs "$service" > "$backup_dir/${service}_logs.txt" 2>/dev/null || true
            fi
        done
    fi

    echo "$backup_dir" > /tmp/current_backup_path
    log_success "‚úÖ Backup criado em: $backup_dir"
}

# Fun√ß√£o de rollback autom√°tico
auto_rollback() {
    log_warning "üîÑ Iniciando rollback autom√°tico..."

    local backup_path=$(cat /tmp/current_backup_path 2>/dev/null || echo "")

    if [ -d "$backup_path" ]; then
        log_info "Restaurando configura√ß√µes do backup..."

        # Parar containers atuais
        docker-compose down --remove-orphans 2>/dev/null || true

        # Restaurar arquivos de configura√ß√£o
        if [ -f "$backup_path/docker-compose.yml" ]; then
            cp "$backup_path/docker-compose.yml" . 2>/dev/null || true
        fi

        if [ -f "$backup_path/.env" ]; then
            cp "$backup_path/.env" . 2>/dev/null || true
        fi

        # Tentar restaurar estado anterior
        if [ -f "$backup_path/postgres_backup.sql" ]; then
            log_info "Restaurando banco de dados..."
            docker-compose up -d postgres 2>/dev/null || true
            sleep 30
            cat "$backup_path/postgres_backup.sql" | docker-compose exec -T postgres psql -U postgres 2>/dev/null || true
        fi

        log_success "‚úÖ Rollback conclu√≠do"
    else
        log_warning "‚ö†Ô∏è Backup n√£o encontrado. Rollback manual necess√°rio."
    fi
}

# Criar backup pr√©-deploy
create_pre_deploy_backup

cat > backup.sh <<EOF
#!/bin/bash
BACKUP_DIR="/home/\$USER/backups"
DATE=\$(date +%Y%m%d_%H%M%S)
mkdir -p \$BACKUP_DIR

echo "üîÑ Iniciando backup V3 em \$DATE..."

# Backup PostgreSQL
echo "üìä Backup do banco de dados..."
docker exec siqueira-postgres pg_dump -U sitejuarez bdsitejuarez > \$BACKUP_DIR/db_\$DATE.sql 2>/dev/null && echo "‚úÖ Banco OK" || echo "‚ùå Banco falhou"

# Backup uploads
if [ -d "uploads" ]; then
    echo "üìÅ Backup dos uploads..."
    tar -czf \$BACKUP_DIR/uploads_\$DATE.tar.gz uploads/ 2>/dev/null && echo "‚úÖ Uploads OK" || echo "‚ùå Uploads falhou"
fi

# Backup configura√ß√µes
echo "‚öôÔ∏è Backup das configura√ß√µes..."
cp .env \$BACKUP_DIR/env_\$DATE.backup 2>/dev/null && echo "‚úÖ .env OK" || echo "‚ùå .env falhou"
cp docker-compose.yml \$BACKUP_DIR/compose_\$DATE.backup 2>/dev/null && echo "‚úÖ docker-compose OK" || echo "‚ùå docker-compose falhou"

# Backup logs
echo "üìù Backup dos logs..."
cp deploy*.log \$BACKUP_DIR/ 2>/dev/null && echo "‚úÖ Logs OK" || echo "‚ö†Ô∏è Logs n√£o encontrados"

# Manter apenas 7 backups
echo "üßπ Limpando backups antigos..."
find \$BACKUP_DIR -type f -mtime +7 -delete 2>/dev/null

echo "‚úÖ Backup V3 \$DATE conclu√≠do!"
echo "üìÅ Localiza√ß√£o: \$BACKUP_DIR"
ls -la \$BACKUP_DIR/*\$DATE* 2>/dev/null || true
EOF
chmod +x backup.sh

# Configurar cron para backup autom√°tico
(crontab -l 2>/dev/null; echo "0 2 * * * $(pwd)/backup.sh") | crontab -
log_success "‚úÖ Backup autom√°tico configurado (2h da manh√£)!"
show_progress 12 $TOTAL_STEPS

# ============= PASSO 12: BUILD E DEPLOY =============
log_step 12 $TOTAL_STEPS "Build e deploy do sistema"

log_info "üöÄ Construindo e executando sistema ultra-robusto V3..."

# Verifica√ß√£o pr√©-build
log_info "üîç Verifica√ß√£o pr√©-build..."
check_and_fix_docker
check_and_fix_disk_space

# Build com monitoramento avan√ßado
log_info "üì¶ Fazendo pull das imagens base..."
if ! run_with_progress "docker-compose pull --parallel" "Pull das imagens" 600 5; then
    log_fix "Pull falhou. Tentando pull sequencial..."
    run_with_progress "docker-compose pull" "Pull sequencial das imagens" 900 3
fi

log_info "üî® Construindo aplica√ß√£o com cache otimizado..."
# Limpeza preventiva antes do build
docker builder prune -f 2>/dev/null || true

if ! run_with_progress "docker-compose build --parallel --no-cache" "Build da aplica√ß√£o" 1200 3; then
    log_fix "Build paralelo falhou. Tentando build sequencial..."
    run_with_progress "docker-compose build" "Build sequencial" 1800 2
fi

# Verifica√ß√£o p√≥s-build
log_info "üîç Verifica√ß√£o p√≥s-build..."
docker images | grep -E "(siqueira|<none>)" || true

log_info "üöÄ Iniciando todos os servi√ßos com restart autom√°tico..."
if ! run_with_progress "docker-compose up -d --remove-orphans" "Iniciar servi√ßos" 300 3; then
    log_fix "In√≠cio falhou. Tentando in√≠cio for√ßado..."
    docker-compose down --remove-orphans 2>/dev/null || true
    sleep 5
    run_with_progress "docker-compose up -d --force-recreate" "In√≠cio for√ßado" 300 2
fi

log_success "‚úÖ Sistema iniciado!"
show_progress 13 $TOTAL_STEPS

# ============= PASSO 13: AGUARDAR E MONITORAR =============
log_step 13 $TOTAL_STEPS "Aguardando servi√ßos ficarem prontos"

log_info "‚è≥ Aguardando todos os servi√ßos ficarem online..."

# Sistema ultra-robusto de monitoramento e auto-corre√ß√£o
log_info "üîÑ Iniciando monitoramento inteligente com auto-corre√ß√£o..."

for i in {1..24}; do  # Tempo estendido para deploy robusto
    wait_with_countdown 15 "Aguardando e monitorando servi√ßos... (${i}/24)"

    # Verificar containers com detalhes
    RUNNING_CONTAINERS=$(docker-compose ps --filter status=running --services 2>/dev/null | wc -l)
    TOTAL_SERVICES=$(docker-compose config --services 2>/dev/null | wc -l)

    realtime_echo "${BLUE}üìä Status: $RUNNING_CONTAINERS/$TOTAL_SERVICES containers rodando${NC}"

    # Mostrar status detalhado
    realtime_echo "${CYAN}üê≥ Status dos containers:${NC}"
    docker-compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null | head -10 || true

    # Auto-corre√ß√£o proativa para containers com problemas
    FAILED_CONTAINERS=$(docker-compose ps --filter status=exited --services 2>/dev/null)
    if [ ! -z "$FAILED_CONTAINERS" ]; then
        log_warning "‚ö†Ô∏è Containers com problemas detectados: $FAILED_CONTAINERS"

        echo "$FAILED_CONTAINERS" | while read container; do
            if [ ! -z "$container" ]; then
                log_fix "üîß Auto-corrigindo $container..."

                # Obter logs do erro
                local error_logs=$(docker-compose logs --tail=10 "$container" 2>/dev/null)

                # Auto-diagn√≥stico espec√≠fico por container
                case "$container" in
                    *"postgres"*|*"db"*)
                        log_fix "üìä Corrigindo PostgreSQL..."
                        # Verificar se porta 5432 est√° ocupada
                        if netstat -tlnp | grep -q ":5432"; then
                            sudo systemctl stop postgresql 2>/dev/null || true
                        fi
                        docker-compose restart postgres 2>/dev/null || true
                        ;;
                    *"redis"*)
                        log_fix "üî¥ Corrigindo Redis..."
                        if netstat -tlnp | grep -q ":6379"; then
                            sudo systemctl stop redis-server 2>/dev/null || true
                        fi
                        docker-compose restart redis 2>/dev/null || true
                        ;;
                    *"app"*|*"web"*)
                        log_fix "üåê Corrigindo aplica√ß√£o..."
                        # Verificar se depend√™ncias est√£o rodando
                        docker-compose restart postgres redis 2>/dev/null || true
                        sleep 10
                        docker-compose restart app 2>/dev/null || true
                        ;;
                    *"traefik"*)
                        log_fix "üîÄ Corrigindo Traefik..."
                        check_and_fix_port_conflicts
                        docker-compose restart traefik 2>/dev/null || true
                        ;;
                esac

                log_info "Logs recentes do $container:"
                echo "$error_logs" | tail -5 || true
                echo ""
            fi
        done

        # Aguardar containers reiniciarem
        log_info "‚è≥ Aguardando containers reiniciarem..."
        sleep 15
    fi

    # Monitoramento inteligente de sa√∫de
    health_check_containers

    # Verificar progresso dos health checks
    realtime_echo "${CYAN}üè• Health checks:${NC}"
    docker-compose ps --format "table {{.Name}}\t{{.Status}}" 2>/dev/null | grep -E "(healthy|unhealthy)" || echo "Aguardando health checks..."

    # Se todos os containers est√£o rodando, fazer verifica√ß√µes avan√ßadas
    if [ $RUNNING_CONTAINERS -eq $TOTAL_SERVICES ] && [ $RUNNING_CONTAINERS -gt 0 ]; then
        log_success "üéØ Todos os containers rodando! Verificando conectividade..."

        # Testes de conectividade progressivos
        local api_tests=0

        # Teste 1: Health endpoint
        if timeout 10 curl -s http://localhost:3000/api/health > /dev/null 2>&1; then
            api_tests=$((api_tests + 1))
            log_success "‚úÖ API Health OK"
        fi

        # Teste 2: Ping endpoint
        if timeout 10 curl -s http://localhost:3000/api/ping > /dev/null 2>&1; then
            api_tests=$((api_tests + 1))
            log_success "‚úÖ API Ping OK"
        fi

        # Teste 3: Homepage
        if timeout 10 curl -s http://localhost:3000/ | grep -q "Siqueira" 2>/dev/null; then
            api_tests=$((api_tests + 1))
            log_success "‚úÖ Homepage OK"
        fi

        # Se pelo menos 2 testes passaram, considerar sucesso
        if [ $api_tests -ge 2 ]; then
            log_success "üöÄ Sistema funcionando! Deploy quase conclu√≠do..."
            break
        fi
    fi

    # Auto-otimiza√ß√£o a cada 5 ciclos
    if [ $((i % 5)) -eq 0 ]; then
        log_info "üîß Auto-otimiza√ß√£o peri√≥dica..."
        monitor_system_health

        # Verificar se precisa liberar recursos
        check_and_fix_disk_space
    fi
done

# Fun√ß√£o para verificar sa√∫de dos containers
health_check_containers() {
    local containers=$(docker-compose ps --services 2>/dev/null)

    echo "$containers" | while read container; do
        if [ ! -z "$container" ]; then
            local container_id=$(docker-compose ps -q "$container" 2>/dev/null)
            if [ ! -z "$container_id" ]; then
                local health=$(docker inspect "$container_id" --format='{{.State.Health.Status}}' 2>/dev/null || echo "no-healthcheck")

                case "$health" in
                    "healthy")
                        realtime_echo "${GREEN}‚úÖ $container: Saud√°vel${NC}"
                        ;;
                    "unhealthy")
                        log_warning "‚ùå $container: N√£o saud√°vel"
                        # Tentar reiniciar container n√£o saud√°vel
                        docker-compose restart "$container" 2>/dev/null || true
                        ;;
                    "starting")
                        realtime_echo "${YELLOW}‚è≥ $container: Iniciando...${NC}"
                        ;;
                    *)
                        realtime_echo "${BLUE}‚ÑπÔ∏è $container: Sem health check${NC}"
                        ;;
                esac
            fi
        fi
    done
}

show_progress 14 $TOTAL_STEPS

# ============= PASSO 14: VERIFICA√á√ÉO FINAL ULTRA-ROBUSTA =============
log_step 14 $TOTAL_STEPS "Verifica√ß√£o final ultra-robusta com auto-corre√ß√£o"

log_info "üîç Executando bateria completa de testes com auto-corre√ß√£o..."

# Sistema de verifica√ß√£o ultra-robusto
deploy_success=true

# 1. Verifica√ß√£o de containers
verify_containers() {
    log_info "üê≥ Verificando status dos containers..."

    CONTAINERS_UP=$(docker-compose ps --filter status=running --services 2>/dev/null | wc -l)
    TOTAL_SERVICES=$(docker-compose config --services 2>/dev/null | wc -l)

    if [ $CONTAINERS_UP -eq $TOTAL_SERVICES ] && [ $CONTAINERS_UP -gt 0 ]; then
        log_success "‚úÖ Todos os $TOTAL_SERVICES containers rodando!"

        # Verificar health status
        local unhealthy_count=0
        docker-compose ps --format "table {{.Name}}\t{{.Status}}" | while read line; do
            if echo "$line" | grep -q "unhealthy"; then
                unhealthy_count=$((unhealthy_count + 1))
            fi
        done

        if [ $unhealthy_count -gt 0 ]; then
            log_warning "‚ö†Ô∏è $unhealthy_count containers n√£o saud√°veis. Tentando corre√ß√£o..."
            docker-compose restart 2>/dev/null || true
            sleep 30
        fi
    else
        log_warning "‚ö†Ô∏è $CONTAINERS_UP de $TOTAL_SERVICES containers rodando"
        deploy_success=false

        # Tentar corrigir containers parados
        local failed_containers=$(docker-compose ps --filter status=exited --services 2>/dev/null)
        if [ ! -z "$failed_containers" ]; then
            log_fix "üîß Tentando reiniciar containers parados..."
            echo "$failed_containers" | while read container; do
                if [ ! -z "$container" ]; then
                    docker-compose restart "$container" 2>/dev/null || true
                fi
            done
            sleep 15
        fi
    fi
}

# 2. Teste de APIs ultra-robusto
test_apis_comprehensive() {
    log_info "üß™ Testando APIs com verifica√ß√£o completa..."

    local api_tests_passed=0
    local total_api_tests=6

    # Teste 1: Health Check b√°sico
    if timeout 15 curl -sf http://localhost:3000/api/health > /dev/null 2>&1; then
        log_success "‚úÖ API Health Check: OK"
        api_tests_passed=$((api_tests_passed + 1))
    else
        log_warning "‚ùå API Health Check: FAIL"
    fi

    # Teste 2: Ping endpoint
    if timeout 15 curl -sf http://localhost:3000/api/ping > /dev/null 2>&1; then
        log_success "‚úÖ API Ping: OK"
        api_tests_passed=$((api_tests_passed + 1))
    else
        log_warning "‚ùå API Ping: FAIL"
    fi

    # Teste 3: Homepage principal
    if timeout 15 curl -sf http://localhost:3000/ | grep -q "Siqueira" 2>/dev/null; then
        log_success "‚úÖ Homepage: OK"
        api_tests_passed=$((api_tests_passed + 1))
    else
        log_warning "‚ùå Homepage: FAIL"
    fi

    # Teste 4: Traefik Dashboard
    if timeout 10 curl -sf http://localhost:8080/api/overview > /dev/null 2>&1; then
        log_success "‚úÖ Traefik Dashboard: OK"
        api_tests_passed=$((api_tests_passed + 1))
    else
        log_warning "‚ùå Traefik Dashboard: FAIL"
    fi

    # Teste 5: PostgreSQL conectividade
    if docker-compose exec -T postgres pg_isready -U sitejuarez > /dev/null 2>&1; then
        log_success "‚úÖ PostgreSQL: OK"
        api_tests_passed=$((api_tests_passed + 1))
    else
        log_warning "‚ùå PostgreSQL: FAIL"
    fi

    # Teste 6: Redis conectividade
    if docker-compose exec -T redis redis-cli ping | grep -q PONG 2>/dev/null; then
        log_success "‚úÖ Redis: OK"
        api_tests_passed=$((api_tests_passed + 1))
    else
        log_warning "‚ùå Redis: FAIL"
    fi

    local api_success_rate=$((api_tests_passed * 100 / total_api_tests))

    if [ $api_success_rate -ge 80 ]; then
        log_success "üéØ APIs funcionando! Taxa de sucesso: ${api_success_rate}%"
    else
        log_warning "‚ö†Ô∏è APIs com problemas. Taxa de sucesso: ${api_success_rate}%"
        deploy_success=false

        # Tentar corre√ß√£o autom√°tica de APIs
        log_fix "üîß Tentando corre√ß√£o autom√°tica das APIs..."
        docker-compose restart app 2>/dev/null || true
        sleep 20

        # Novo teste r√°pido
        if timeout 10 curl -sf http://localhost:3000/api/health > /dev/null 2>&1; then
            log_success "‚úÖ Corre√ß√£o autom√°tica funcionou!"
            deploy_success=true
        fi
    fi
}

# 3. Verifica√ß√£o de recursos e otimiza√ß√£o
verify_and_optimize_resources() {
    log_info "üíª Verificando recursos e otimizando..."

    # Verificar uso de CPU
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//')
    if (( $(echo "$cpu_usage > 80" | bc -l 2>/dev/null || echo 0) )); then
        log_warning "‚ö†Ô∏è Alto uso de CPU: ${cpu_usage}%"
        log_fix "Otimizando containers..."
        docker update --cpus="0.5" $(docker-compose ps -q) 2>/dev/null || true
    fi

    # Verificar uso de mem√≥ria
    local mem_usage=$(free | grep Mem | awk '{printf "%.0f", $3/$2 * 100.0}')
    if [ "$mem_usage" -gt 85 ]; then
        log_warning "‚ö†Ô∏è Alto uso de mem√≥ria: ${mem_usage}%"
        log_fix "Liberando cache e otimizando..."
        sync && echo 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null 2>&1 || true
        docker update --memory="512m" $(docker-compose ps -q) 2>/dev/null || true
    fi

    # Verificar espa√ßo em disco
    check_and_fix_disk_space
}

# 4. Relat√≥rio final de status
generate_final_status_report() {
    log_info "üìä Gerando relat√≥rio final de status..."

    realtime_echo ""
    realtime_echo "${PURPLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    realtime_echo "${PURPLE}üìã RELAT√ìRIO FINAL DO DEPLOY V3${NC}"
    realtime_echo "${PURPLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"

    # Status dos containers
    realtime_echo "${CYAN}üê≥ Status dos Containers:${NC}"
    docker-compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || true

    # Status dos recursos
    realtime_echo ""
    realtime_echo "${CYAN}üíª Recursos do Sistema:${NC}"
    local mem_total=$(free -h | awk 'NR==2{print $2}')
    local mem_used=$(free -h | awk 'NR==2{print $3}')
    local disk_used=$(df -h / | awk 'NR==2{print $5}')

    realtime_echo "   üíæ Mem√≥ria: $mem_used / $mem_total"
    realtime_echo "   üóÑÔ∏è Disco: $disk_used usado"
    realtime_echo "   üñ•Ô∏è CPU: $(nproc) cores dispon√≠veis"

    # URLs de acesso
    realtime_echo ""
    realtime_echo "${CYAN}üåê URLs de Acesso:${NC}"
    if [ "$USE_ALT_PORTS" = true ]; then
        realtime_echo "   ‚Ä¢ Site: http://IP_VPS:8000"
        realtime_echo "   ‚Ä¢ HTTPS: https://IP_VPS:8443"
        realtime_echo "   ‚Ä¢ Traefik: http://IP_VPS:8080"
    else
        realtime_echo "   ‚Ä¢ Site: https://$DOMAIN"
        realtime_echo "   ‚Ä¢ Traefik: https://traefik.$DOMAIN"
    fi

    # Status dos Portainers
    realtime_echo ""
    realtime_echo "${CYAN}üê≥ Portainers Configurados:${NC}"

    # Verificar Portainer 1
    if timeout 5 curl -s http://localhost:9001 > /dev/null 2>&1; then
        realtime_echo "   ‚úÖ Portainer 1: https://portainer.$DOMAIN (porta 9001)"
    else
        realtime_echo "   ‚ùå Portainer 1: N√£o acess√≠vel"
    fi

    # Verificar Portainer 2
    if timeout 5 curl -s http://localhost:9002 > /dev/null 2>&1; then
        realtime_echo "   ‚úÖ Portainer 2: https://portainer.${DOMAIN2:-"domain2.local"} (porta 9002)"
    else
        realtime_echo "   ‚ùå Portainer 2: N√£o acess√≠vel"
    fi

    # Verificar se Portainer antigo ainda existe
    if docker ps | grep -q portainer && ! docker ps | grep -q "siqueira-portainer"; then
        realtime_echo "   ‚ö†Ô∏è Portainer antigo ainda rodando - pode precisar de limpeza manual"
    fi

    # Status das stacks
    local total_stacks=$(docker ps -a --filter "label=com.docker.compose.project" --format "{{.Label \"com.docker.compose.project\"}}" | sort | uniq | grep -v '^$' | wc -l)
    local running_stacks=$(docker ps --filter "label=com.docker.compose.project" --format "{{.Label \"com.docker.compose.project\"}}" | sort | uniq | grep -v '^$' | wc -l)

    if [ $total_stacks -gt 0 ]; then
        realtime_echo ""
        realtime_echo "${CYAN}üìã Status das Stacks Docker:${NC}"
        realtime_echo "   ‚Ä¢ Total de stacks: $total_stacks"
        realtime_echo "   ‚Ä¢ Stacks funcionando: $running_stacks"

        if [ $running_stacks -eq $total_stacks ]; then
            realtime_echo "   ‚úÖ Todas as stacks funcionando!"
        else
            local problematic=$((total_stacks - running_stacks))
            realtime_echo "   ‚ö†Ô∏è $problematic stacks ainda com problemas"
            realtime_echo "   üí° Use os Portainers para gerenciar stacks manualmente"
        fi
    fi

    # Status final
    realtime_echo ""
    if [ "$deploy_success" = true ]; then
        realtime_echo "${GREEN}üéâ DEPLOY CONCLU√çDO COM SUCESSO!${NC}"
        realtime_echo "${GREEN}‚úÖ Sistema 100% funcional e otimizado${NC}"
    else
        realtime_echo "${YELLOW}‚ö†Ô∏è DEPLOY CONCLU√çDO COM AVISOS${NC}"
        realtime_echo "${YELLOW}‚ö†Ô∏è Alguns componentes podem precisar de aten√ß√£o${NC}"
    fi

    realtime_echo "${PURPLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
}

# Executar verifica√ß√µes
verify_containers
test_apis_comprehensive
verify_and_optimize_resources
generate_final_status_report

# Se deploy falhou cr√≠tico, oferecer rollback
if [ "$deploy_success" = false ]; then
    realtime_echo ""
    realtime_echo "${RED}‚ùå Deploy com falhas cr√≠ticas detectadas${NC}"
    realtime_echo "${YELLOW}Deseja fazer rollback autom√°tico? (y/N):${NC}"

    read -t 30 -r rollback_choice || rollback_choice="n"

    if [[ "$rollback_choice" == "y" || "$rollback_choice" == "Y" ]]; then
        auto_rollback
    else
        log_info "Continuando sem rollback. Sistema pode estar inst√°vel."
    fi
fi

show_progress 15 $TOTAL_STEPS

# ============= PASSO 15: CRIAR DOCUMENTA√á√ÉO =============
log_step 15 $TOTAL_STEPS "Cria√ß√£o da documenta√ß√£o final"

cat > ACESSO_MEGA_DEPLOY_V3.md <<EOF
# üöÄ MEGA DEPLOY AUTOM√ÅTICO V3 - Siqueira Campos Im√≥veis

## ‚úÖ DEPLOY V3 EXECUTADO COM SUCESSO!

### üÜï Novidades V3 - Logs em Tempo Real:
- üìù **Logs Tempo Real**: Todo o processo √© exibido em tempo real
- üìä **Progress Bar**: Acompanhe o progresso de cada etapa
- üîÑ **Retry Logic**: Tentativas autom√°ticas em caso de falha
- üßπ **Cleanup Autom√°tico**: Tratamento adequado de interrup√ß√µes
- üîç **Health Checks**: Monitoramento cont√≠nuo dos servi√ßos
- üåê **Conectividade Check**: Verifica√ß√£o de internet antes do deploy
- üìÅ **Backup Melhorado**: Inclui logs e configura√ß√µes

### üìù Arquivo de Log
- **Log File**: $LOG_FILE
- **Localiza√ß√£o**: $(pwd)/$LOG_FILE
- **Comando para ver**: \`tail -f $LOG_FILE\`

### üåê URLs do Sistema
EOF

if [ "$USE_ALT_PORTS" = true ]; then
cat >> ACESSO_MEGA_DEPLOY_V3.md <<EOF
- **Site Principal**: http://IP_VPS:8000 (HTTP) | https://IP_VPS:8443 (HTTPS)
- **Traefik Dashboard**: http://IP_VPS:8080

‚ö†Ô∏è **Usando portas alternativas devido a conflito na porta 80**
**Para produ√ß√£o, configure seu proxy/load balancer para redirecionar:**
- Porta 80 ‚Üí 8000
- Porta 443 ‚Üí 8443
EOF
else
cat >> ACESSO_MEGA_DEPLOY_V3.md <<EOF
- **Site Principal**: https://$DOMAIN
- **Traefik Dashboard**: https://traefik.$DOMAIN
EOF
fi

cat >> ACESSO_MEGA_DEPLOY_V3.md <<EOF

### üîê Credenciais Geradas Automaticamente
- **N8N**: admin / $N8N_PASSWORD
- **Evolution API Key**: $EVOLUTION_KEY
- **PostgreSQL**: sitejuarez / $DB_PASSWORD

### üõ†Ô∏è Stack Implementada V3
‚úÖ Traefik (Proxy + SSL autom√°tico + Health checks)
‚úÖ Let's Encrypt (SSL/HTTPS autom√°tico)
‚úÖ PostgreSQL (Banco principal + otimizado + health checks)
‚úÖ Redis (Cache + health checks)
‚úÖ Express.js V3 (Servidor com monitoramento)
‚úÖ Docker Compose (Orquestra√ß√£o inteligente)
‚úÖ Logs em Tempo Real (Deploy vis√≠vel)
‚úÖ Retry Logic (Tentativas autom√°ticas)
‚úÖ Health Monitoring (Verifica√ß√£o cont√≠nua)

### üìä Comandos √öteis V3
\`\`\`bash
# Ver status detalhado
docker-compose ps

# Ver logs em tempo real
docker-compose logs -f [servi√ßo]

# Ver health checks
docker-compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"

# Reiniciar servi√ßo espec√≠fico
docker-compose restart [servi√ßo]

# Ver logs do deploy
tail -f $LOG_FILE

# Backup manual V3
./backup.sh

# Verificar sa√∫de dos containers
docker inspect \$(docker-compose ps -q) --format="{{.Name}}: {{.State.Health.Status}}"
\`\`\`

### üîí Seguran√ßa V3
- Firewall configurado (portas 22, 80, 443, 8000, 8080, 8443)
- SSL autom√°tico via Let's Encrypt
- Backup autom√°tico di√°rio com logs (2h da manh√£)
- Headers de seguran√ßa aplicados
- Health checks para todos os servi√ßos
- Graceful shutdown configurado

### üìä Monitoramento
- **Health Checks**: Todos os servi√ßos t√™m verifica√ß√£o de sa√∫de
- **API Monitoring**: /api/health endpoint dispon√≠vel
- **Logs Centralizados**: docker-compose logs
- **M√©tricas**: Dispon√≠veis via API /api/ping

### üöÄ Pr√≥ximos Passos
1. Configure DNS do dom√≠nio para apontar para este servidor
2. Aguarde propaga√ß√£o DNS (5-30 minutos)
3. SSL ser√° ativado automaticamente
4. Monitore os logs: \`tail -f $LOG_FILE\`
5. Verifique health: \`docker-compose ps\`

### üÜò Troubleshooting V3
- **Container falhando**: \`docker-compose logs [container]\`
- **API n√£o respondendo**: \`curl http://localhost:3000/api/health\`
- **SSL n√£o ativando**: Aguarde propaga√ß√£o DNS
- **Porto ocupado**: Script detecta e usa portas alternativas
- **Ver processo completo**: \`cat $LOG_FILE\`

---
**MEGA DEPLOY AUTOM√ÅTICO V3 executado com sucesso! üéâ**
**Logs em Tempo Real + Health Checks + Retry Logic + Monitoramento**
**Desenvolvido por Kryonix - Zero configura√ß√£o manual**

**Log completo salvo em: $LOG_FILE**
EOF

# ============= RESULTADO FINAL V3 =============
realtime_echo ""
realtime_echo "${PURPLE}üéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâ${NC}"
realtime_echo "${GREEN}üöÄ MEGA DEPLOY AUTOM√ÅTICO V3 CONCLU√çDO! üöÄ${NC}"
realtime_echo "${PURPLE}üéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâüéâÔøΩÔøΩüéâüéâüéâüéâ${NC}"
realtime_echo ""
realtime_echo "${CYAN}üÜï Novidades V3 - Logs em Tempo Real:${NC}"
realtime_echo "   ‚Ä¢ üìù Logs em tempo real durante todo o processo"
realtime_echo "   ‚Ä¢ üìä Progress bar visual"
realtime_echo "   ‚Ä¢ üîÑ Retry logic autom√°tico"
realtime_echo "   ‚Ä¢ üßπ Cleanup em interrup√ß√µes"
realtime_echo "   ‚Ä¢ üîç Health checks melhorados"
realtime_echo "   ‚Ä¢ üåê Verifica√ß√£o de conectividade"
realtime_echo ""

if [ "$USE_ALT_PORTS" = true ]; then
    realtime_echo "${YELLOW}‚ö†Ô∏è Usando portas alternativas:${NC}"
    realtime_echo "   ‚Ä¢ HTTP: ${YELLOW}http://IP_VPS:8000${NC}"
    realtime_echo "   ‚Ä¢ HTTPS: ${YELLOW}https://IP_VPS:8443${NC}"
    realtime_echo "   ‚Ä¢ Traefik: ${YELLOW}http://IP_VPS:8080${NC}"
    realtime_echo ""
    log_warning "Porta 80 estava ocupada - usando portas alternativas"
else
    realtime_echo "${CYAN}üåê URLs padr√£o configuradas:${NC}"
    realtime_echo "   ‚Ä¢ Site: ${YELLOW}https://$DOMAIN${NC}"
    realtime_echo "   ‚Ä¢ Traefik: ${YELLOW}https://traefik.$DOMAIN${NC}"
fi

realtime_echo ""
realtime_echo "${CYAN}üìù Log completo salvo em: ${YELLOW}$LOG_FILE${NC}"
realtime_echo "${CYAN}üîê Credenciais salvas em: ${YELLOW}ACESSO_MEGA_DEPLOY_V3.md${NC}"
realtime_echo ""
realtime_echo "${GREEN}‚úÖ Sistema V3 100% funcional com:${NC}"
realtime_echo "   üìù Logs em tempo real"
realtime_echo "   üìä Progress bar visual"
realtime_echo "   üîÑ Retry logic autom√°tico"
realtime_echo "   üßπ Cleanup autom√°tico"
realtime_echo "   üîç Health checks melhorados"
realtime_echo "   üê≥ Docker + Docker Compose"
realtime_echo "   üîÄ Traefik (Proxy reverso)"
realtime_echo "   üîí Let's Encrypt (SSL autom√°tico)"
realtime_echo "   üóÑÔ∏è PostgreSQL + Redis"
realtime_echo "   üíæ Backup autom√°tico aprimorado"
realtime_echo "   üîí Firewall configurado"
realtime_echo "   üåê Verifica√ß√£o de conectividade"
realtime_echo ""
realtime_echo "${BLUE}üìä Comandos √∫teis:${NC}"
realtime_echo "${BLUE}   docker-compose ps${NC} - Ver status"
realtime_echo "${BLUE}   docker-compose logs -f${NC} - Ver logs"
realtime_echo "${BLUE}   tail -f $LOG_FILE${NC} - Ver log do deploy"
realtime_echo "${BLUE}   ./backup.sh${NC} - Backup manual"
realtime_echo ""
realtime_echo "${PURPLE}üè† Siqueira Campos Im√≥veis V3 ONLINE! üè†${NC}"
realtime_echo "${GREEN}Deploy executado em $(date)${NC}"
realtime_echo ""

# Finaliza√ß√£o melhorada com op√ß√£o de manter terminal aberto
realtime_echo ""
realtime_echo "${GREEN}üéâ DEPLOY V3 FINALIZADO COM SUCESSO!${NC}"
realtime_echo ""

# Perguntar se usu√°rio quer manter terminal aberto
realtime_echo "${YELLOW}Op√ß√µes:${NC}"
realtime_echo "1) Manter terminal aberto para monitoramento"
realtime_echo "2) Finalizar script agora"
realtime_echo "3) Mostrar logs dos containers"
realtime_echo ""

# Aguardar por 15 segundos ou input do usu√°rio
realtime_echo "${CYAN}Escolha uma op√ß√£o (1-3) ou aguarde 15s para finalizar:${NC}"

# Usar timeout para n√£o travar indefinidamente
if read -t 15 -r choice; then
    case $choice in
        1)
            realtime_echo "${GREEN}Mantendo terminal aberto para monitoramento...${NC}"
            realtime_echo "${CYAN}Pressione Ctrl+C para sair quando quiser${NC}"
            realtime_echo ""

            # Loop de monitoramento
            while true; do
                realtime_echo "=== Status dos Containers ($(date)) ==="
                docker-compose ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || true
                echo ""

                # Verificar APIs
                if curl -s http://localhost:3000/api/health > /dev/null 2>&1; then
                    realtime_echo "‚úÖ API Health: OK"
                else
                    realtime_echo "‚ùå API Health: FAIL"
                fi

                echo ""
                wait_with_countdown 30 "Pr√≥xima verifica√ß√£o em"
            done
            ;;
        2)
            realtime_echo "${GREEN}Finalizando script...${NC}"
            ;;
        3)
            realtime_echo "${CYAN}Logs dos containers:${NC}"
            docker-compose logs --tail=20 2>/dev/null || true

            realtime_echo ""
            realtime_echo "${YELLOW}Pressione ENTER para finalizar...${NC}"
            read -r
            ;;
        *)
            realtime_echo "${YELLOW}Op√ß√£o inv√°lida. Finalizando...${NC}"
            ;;
    esac
else
    realtime_echo ""
    realtime_echo "${GREEN}Timeout atingido. Finalizando script...${NC}"
fi

# Restaurar descritores de arquivo com seguran√ßa
if [[ -n "${3:-}" ]] && [[ -n "${4:-}" ]]; then
    exec 1>&3 2>&4 2>/dev/null || true
fi

realtime_echo ""
realtime_echo "${GREEN}‚úÖ MEGA DEPLOY V3 FINALIZADO!${NC}"
realtime_echo "${CYAN}üìù Log salvo em: ${LOG_FILE:-"n√£o dispon√≠vel"}${NC}"
realtime_echo "${CYAN}üìã Documenta√ß√£o: ACESSO_MEGA_DEPLOY_V3.md${NC}"
realtime_echo ""
realtime_echo "${YELLOW}Pressione ENTER para finalizar ou Ctrl+C para sair...${NC}"

# Aguardar indefinidamente at√© o usu√°rio pressionar ENTER
read -r final_input || true

realtime_echo "${GREEN}Script finalizado pelo usu√°rio. Obrigado!${NC}"
